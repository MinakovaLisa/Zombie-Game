{"version":3,"sources":["features/Dice.tsx","features/MoveControls.tsx","shared/ItemTypes.ts","components/CellItem.tsx","business/phases/common/getNextPlayerCoord.ts","business/phases/common/getNeighboringCellList.ts","assets/door2.png","assets/window2.png","features/PlayGrid/Barrier.tsx","assets/door.png","assets/window.png","business/effects/useOpenCardAnimation.ts","components/common/CommonCard/brain_4.png","components/common/CommonCard/index.tsx","components/Health/health.png","components/Health/HealthCard.tsx","components/Player/player.png","components/Player/player2.png","components/Player/player3.png","components/Player/player4.png","components/common/DragPreview/StyledCommonPlayerCard.tsx","components/common/DragPreview/PreviewDrag.tsx","components/Player/PlayerCard.tsx","components/Player/Player.tsx","components/Boards/boards.png","components/Boards/BoardsCard.tsx","components/Weapon/weapon.png","components/Weapon/WeaponCard.tsx","components/Enemy/zombie.png","components/Enemy/EnemyView.tsx","components/Enemy/EnemyCard.tsx","features/PlayGrid/CardListEl.tsx","features/PlayGrid/PlayerList.tsx","features/PlayGrid/Cell.tsx","features/PlayGrid/FilledPlayGrid.tsx","features/PlayGrid/index.tsx","features/PlayGrid/house_2.png","components/HealthSlots.tsx","components/Inventory.tsx","features/PlayerStatus.tsx","features/StatusList.tsx","pages/EndScreen.tsx","features/PlayersStatusList.tsx","pages/StartScreen.tsx","business/initialState/getGameField/getFieldCells.ts","business/initialState/getGameField/spreadCards.ts","business/initialState/getGameField/index.ts","business/initialState/getPlayers.ts","business/initialState/getEnemies.ts","shared/config/walls.ts","business/initialState/index.ts","shared/config/prodConfig.ts","business/phases/waitingStart/index.ts","business/phases/common/getNeighboringCellListMax.ts","business/phases/common/checkCellHasWall.ts","business/phases/gameStarted/playerMove/checkCanTakeCell.ts","business/phases/gameStarted/playerMove/getAvailableCellsMax.ts","business/phases/common/getNextPlayerNumber.ts","business/phases/gameStarted/playerMove/changePlayerCoord.ts","business/phases/common/getStateCardSelected.ts","business/phases/gameStarted/playerMove/index.ts","business/phases/gameStarted/playerMove/getStatePlayerMovedToCoord.ts","business/phases/gameStarted/playerMove/getStatePlayerMoved.ts","business/phases/gameStarted/playerMove/getPlayerMoveResult.ts","business/phases/gameStarted/takeCard/index.ts","business/phases/gameStarted/takeCard/openCard.ts","business/phases/gameStarted/takeCard/deleteCard.ts","business/phases/gameStarted/rollDice/index.ts","business/phases/interactWithEnemy/getBattleResult.ts","business/phases/common/deleteSelectedCard.ts","business/phases/interactWithEnemy/thrownBattleDice.ts","business/phases/interactWithEnemy/selectCard.ts","business/phases/interactWithEnemy/changeSelectedCard.ts","business/phases/interactWithEnemy/index.ts","business/phases/interactWithEnemy/getStateClickedEnemy.ts","business/phases/interactWithEnemy/removeEnemyCard.ts","business/phases/interactWithEnemy/checkCardAppearance.ts","business/phases/interactWithEnemy/openEnemyCard.ts","business/phases/gameStarted/applyCard/getStateGiveCard.ts","business/phases/gameStarted/applyCard/changeHealth.ts","business/phases/gameStarted/applyCard/getStateClickedContextMenu.ts","business/phases/gameStarted/applyCard/getStateHealAnotherPlayer.ts","business/phases/common/canInteractWithCell.ts","business/phases/gameStarted/applyCard/getStateClickedPlayer.ts","business/phases/gameStarted/applyCard/getStateHealCurrPlayer.ts","business/phases/gameStarted/applyCard/index.ts","business/phases/gameStarted/applyCard/getStateHoleFilled.ts","business/phases/gameStarted/applyCard/getAvailableCards.ts","business/phases/endGame/index.ts","business/phases/gameStarted/getPlayersOrder/index.ts","business/phases/enemyMove/checkCanTakeCell.ts","business/phases/enemyMove/getAvailableCells.ts","business/phases/enemyMove/getStateSwitchPlayer.ts","business/phases/enemyMove/index.ts","business/phases/enemyMove/getStateEnemySelected.ts","business/phases/enemyMove/getStateEnemyMovedToCoord.ts","business/phases/enemyMove/getStateEnemyMoved.ts","business/phases/enemyMove/getEnemyMoveResult.ts","business/store.ts","business/reducer.ts","features/SkipButton.tsx","App.tsx","business/effects/useOpenCard.ts","business/effects/usePlayerMove.ts","business/effects/useEndScreen.ts","business/effects/useInteractWithEnemy.ts","business/effects/useApplyCard.ts","reportWebVitals.ts","index.tsx"],"names":["DiceWrap","styled","div","props","direction","DiceButton","button","DiceNumber","Dice","dispatch","useDispatch","diceNumber","useSelector","state","dice","onClick","type","payload","ItemDragTypes","StyledCellItem","mode","needHighlightning","isOver","CellItem","children","hor","vert","useDrop","accept","drop","collect","monitor","hover","ref","getNextPlayerCoord","currentCoord","split","currPlayerHor","currPlayerVert","nextPlayerVert","parseInt","nextPlayerHor","prevPlayerVert","prevPlayerHor","MOVE_DIRECTION_LIST","getNeighboringCellList","prevPlayerCoord","gameField","map","directionItem","coord","filter","cellItem","values","CommonWall","barrierItem","name","isOpen","highlightningList","find","item","WallImage","closedDoor","closedWindow","Wall","Barrier","orderIndex","needApplyBoardCard","isCardApplyPhase","gameState","boardCardActive","playerList","activePlayerNumber","inventory","cardSelected","cellValues","isCurrPlayerAlive","getWallItem","barrier","onClickHandler","barrierList","currPlayerCoord","neighboringCellList","needCheckHighlightning","concat","getHighlightningList","getHighlightningDirection","cellType","currCoord","currCell","availableCellList","currCellHasHole","checkCellOnHole","nextCell","oppositeDirection","getOppositeDirection","nextCellHasHole","availableCell","cell","cellHasWindow","cellHasDoor","useOpenCardAnimation","needRun","maxTime","onTimerEnd","doEffect","cardRef","cardContainerRef","useRef","cardFrontRef","initialState","timeState","timeMark","initialTimeMark","phase","effect","useReducer","action","newTimeState","Date","getTime","useEffect","intervalId","setInterval","currentTime","currTime","timeDiff","Math","floor","timeCurr","getTimerValue","current","style","transform","transition","color","clearInterval","StyledCommonCard","css","img","CardContainer","CardFace","CardFront","CardBack","brainImg","apperance","HealthCard","refList","StyledCommonPlayerCard","image","isCurrent","StyledPreviewWrap","PLayersPortal","Number","coordX","coordY","PreviewDrag","useDragLayer","itemType","getItemType","isDragging","initialOffset","getInitialSourceClientOffset","currentOffset","getDifferenceFromInitialOffset","getItemStyles","display","x","y","WebkitTransform","fieildElem","document","getElementById","styledPreview","ReactDOM","createPortal","renderItem","StyledPlayerCard","PlayerCard","id","gameStateType","playerCardCanBeDragged","useDrag","canDrag","drag","dragPreview","getEmptyImage","captureDraggingState","useMemo","opacity","isCurrPlayer","ContextMenuPortal","PlayerCardList","needReverseCards","needSplitCards","ContextMenu","Button","Player","playerImageList","player","player2","player3","player4","playerListOnCell","numberOfPlayer","length","findIndex","playerCard","orderNumber","playerCardList","playerCardItem","index","coordOfAvailableCards","isActivePlayerAlive","MemoizedClickHandler","String","activePlayerCoord","typeOfChosedCard","calculateHighlightning","contextMenu","className","card","buttonType","showContextMenu","activePLayerCoord","getContextMenuCoord","portal","Fragment","coordString","isActivePlayer","includes","horActive","vertActive","horCurrent","vertCurrent","differenceHor","getNewCoordHor","differenceVert","getNewCoordVert","firstNumber","secondNUmber","difference","BoardsCard","WeaponCard","zombie","EnemyView","enemyCard","enemyCardCanBeDragged","EnemyCard","order","CardList","Card","React","memo","CardListEl","enemyList","deadPlayerList","currEnemyIndex","undefined","hasInventoryCards","cardItem","enemyListOnCell","Object","entries","enemyCardsOnCell","playerCoord","hasEnemyCard","enemyItem","Boolean","MemoCard","cardItemList","inventoryElem","appearance","firstItemIsClosed","isActiveEnemyCard","indexOfActiveCard","isActivePlayerDead","enemyElem","hasTwoCard","PlayerList","playerItem","Wrap","UnderlayerItem","Cell","hasActivePlayerOnCell","hasActiveDeadPlayerOnCell","isPhaseEnemyInteract","isPhaseEnemyMove","console","log","coordOfAvailableCells","isPlayerMoveArea","isPhaseTakeCard","isNeedCreateSeparateWindow","enemyOrderNumber","enemyPlayerCoord","draftCellNumbers","memoizedBarrier","getCardsOnCell","planType","getCardList","getCardListType","foregroundPortal","backgroundCardWrap","FilledPlayGrid","orderGameCells","_config","memoConfig","fullPlayerGrid","playGridMode","memoizedPlayerGrid","GridItem","PlayGrid","test","config","height","finishCoord","MemoizedFilledPlayGrid","HealthSlotList","HealthSlot","isFilled","HealthSlots","getHealthSlot","healthSlotFilled","playerHealth","getPlayerHealth","Array","fill","reduce","prev","currSlot","playersList","health","InventoryWrap","InwentoryRow","Image","boards","weapon","highlighting","Counter","Inventory","PlayerStatusCard","CharacterAvatar","Status","HealthStatus","InventoryStatus","Row","PlayerStatus","avatar","StatusList","useState","status","updateStatus","gameResult","newStatus","getTextStatus","GameScore","amount","EndScreen","StartButton","StartScreen","createEmptyFieldCells","cellList","emptyFieldItem","newEmptyGameField","forEach","getOrganizedFieldCells","emptyField","startIndex","startCoord","finishIndex","getCellsWalls","cellsWithBarrierList","cellsBarrierList","cellBarrier","cellIndex","cellWithoutBarrier","cellsWithBarriers","fromEntries","setCards","currCardSet","cellListWithCards","cellWithCards","getListForCards","emptyCellsList","AMOUNT_EMPTY_CELLS","amoutCurrentCards","canSetAllCards","afforableAmountCards","cardName","error","prevkeyList","randomNumber","getRandomNumber","keyItem","arrNumber","maxNumber","number","random","getGameField","getCellOrder","gameFieldCells","cellsWithAllCards","cardAppearance","amountHealthItems","amountBoardsItems","amountWeaponsItems","filledCells","gameFieldCellsWithPrevious","cellsForCards","filledWithCardsFieldCells","spreadCards","emptyFieldCells","fieldCellsWithWalls","getFieldCells","width","orderList","push","getPlayers","amountPlayers","initialPlayerHealth","getEnemies","getEmptyList","enemiesCoords","getListOfIndexes","getListOfEnemy","amountEnemies","power","CELLS_BARRIERS_LIST","gameFieldWithoutEnemy","getInitialState","PROD_CONFIG","DEV_CONFIG","getConfig","waitingStart","checkCellHasWall","newPlayerCoord","enemyIndex","currCellCoord","currCellHasBarrier","checkCellOnBarrier","nextCellHasBarrier","cellHasWall","cellHasClosedHole","checkNextCellOccupied","newCoord","some","getAvailableCellsMax","coordNeighboringCells","getCoordNeibCells","initPlayerCoord","takeableCoordList","list","counter","i","currList","existingInFieldCoord","coordWithoutRepeat","existCoord","getTakeableCoord","getNeighboringCellListMax","nextPlayerCoord","metBarrier","isLastStepOfMove","isNextCellOcupied","checkCanTakeCell","getNextPlayerNumber","attackInitiator","commonPlayerList","maxPlayerNumber","changePlayerCoord","getStateCardSelected","typeOfSelect","checkCardNonZero","newPlayerList","changeSelectedCard","selectedCard","stateWithSelectedCard","stateWithoutSelectedCard","newInventoryCardUnSelected","newInventoryCardSelected","playerMove","nextPlayerCoordString","join","getStatePlayerMovedToCoord","getStatePlayerMoved","newCellWithPlayer","takeFinish","takeCard","hasCurrCoordEnemy","metEnemyCard","newGameState","newPlayerNumber","getPlayerMoveResult","TypeOfInventoryCard","checkInventoryCardAppearance","getStateOpenCard","getStateCardTaken","getStateDeletedCard","playerCoordIndex","cellWithOpenCard","cardItemWithOpenCard","openCard","newGameField","cardItems","emptyInventory","structuredCardItems","prevItem","currentItem","newInventory","newPlayer","cellWithoutCard","deleteCard","rollDice","getStatePlayerCanFight","getStatePlayerRunsAway","getStatePlayerLoseHealth","newPlayerListObj","newDeadPlayerList","deleteSelectedCard","currInventory","removedCardType","thrownBattleDice","selectCard","currPlayerInventory","isChosenCardWeapon","hasWeapon","newSelectType","hasAnyCardSelected","interactWithEnemy","currEnemy","currEnemyCoord","playerCanFight","keys","key","defeatedEnemy","feature","newEnemyList","getStateClickedEnemy","newEnemyArray","removeEnemyCard","isNeedOpenEnemyCard","checkCardAppearance","openEnemyCard","getBattleResult","getStateGiveCard","recipientPlayerNumber","indexCurrPlayer","currentPlayerInventory","recepientPlayerInventory","sharedCardType","newCurrentPlayerInventory","newRecepientPlayerInventory","changeHealth","indexTarget","getStateClickedContextMenu","typeOfAction","newState","indexChosenPlayer","newHealth","getStateHealAnotherPlayer","closeContextMenu","canInteractWithCell","getStateClickedPlayer","clickedPlayerCard","currPlayer","isCurrentPlayer","canInteractWithPlayer","getCellsForInteract","getStateHealCurrPlayer","clickedPlayerCardNumber","openContextMenu","availableCellsCoords","applyCard","cellWithChosedHole","barriersWithClosedHole","getStateHoleFilled","getAvailableCards","endGame","getPlayersOrder","numberCurrPlayer","nextPlayersNumber","getAvailableCells","deadPLayerCoord","getStateSwitchPlayer","deadPlayerItem","enemyMove","currEnemyCard","isOpenEnemyCard","newDeadPLayerList","getStateEnemySelected","nextEnemyCoordString","enemyListArray","enemy","getStateEnemyMovedToCoord","prevEnemyCoord","nextEnemyCoord","getStateEnemyMoved","indexMetPlayerCard","getEnemyMoveResult","store","createStore","phaseOuter","phaseInner","window","__REDUX_DEVTOOLS_EXTENSION__","SkipButtonContainer","SkipButton","activePlayerDead","isPlayerDead","hasOpenEnemyCard","canSkip","MemoButton","disabled","Field","Game","RightPanel","LeftPanel","GameControls","GetApp","timerChangePlayerHealth","setTimeout","clearTimeout","timerDeleteCard","useOpenCard","usePlayerMove","timer","useEndScreen","timerGetResult","timerRemoveEnemy","useInteractWithEnemy","useApplyCard","memoizedMainPage","getGameScreen","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","render","StrictMode","DndProvider","backend","HTML5Backend"],"mappings":"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","file":"static/js/main.4901721b.chunk.js","sourcesContent":["import React from \"react\";\r\nimport { useDispatch, useSelector } from \"react-redux\";\r\n\r\nimport styled from \"styled-components\";\r\n\r\nimport { State } from \"../business/types\";\r\n\r\nconst DiceWrap = styled.div`\r\n  border: 1px solid lightgray;\r\n  width: 100px;\r\n  height: 100px;\r\n  display: grid;\r\n  background-color: white;\r\n`;\r\n\r\nconst DiceButton = styled.button`\r\n  margin: 0 auto;\r\n  cursor: pointer;\r\n`;\r\n\r\nconst DiceNumber = styled.div`\r\n  height: 30px;\r\n  margin-top: 20px;\r\n  text-align: center;\r\n`;\r\n\r\nconst maxNumber = 4;\r\n\r\nexport const Dice = () => {\r\n  const dispatch = useDispatch();\r\n  const diceNumber = useSelector((state: State) => state.dice);\r\n\r\n  const getNumber = () => {\r\n    return 1;\r\n    // return maxNumber - 1;\r\n    // return Math.floor(Math.random() * maxNumber + 1);\r\n  };\r\n\r\n  return (\r\n    <DiceWrap>\r\n      <DiceNumber>{diceNumber}</DiceNumber>\r\n      <DiceButton\r\n        onClick={() => {\r\n          dispatch({\r\n            type: \"diceThrown\",\r\n            payload: getNumber(),\r\n          });\r\n        }}\r\n      >\r\n        бросить кубик\r\n      </DiceButton>\r\n    </DiceWrap>\r\n  );\r\n};\r\n","import React from \"react\";\r\nimport { useDispatch } from \"react-redux\";\r\n\r\nimport styled from \"styled-components\";\r\n\r\nimport { MoveDirection } from \"../business/types\";\r\n\r\ntype ArrowProps = {\r\n  direction: MoveDirection;\r\n};\r\n\r\nconst Arrow = styled.div<ArrowProps>`\r\n  text-align: center;\r\n  vertical-align: middle;\r\n  border: 1px solid lightgrey;\r\n  cursor: pointer;\r\n  &:hover {\r\n    color: pink;\r\n  }\r\n\r\n  &:active {\r\n    color: red;\r\n  }\r\n\r\n  transform: ${(props) => {\r\n    switch (props.direction) {\r\n      case \"top\":\r\n        return \"rotate(-90deg)\";\r\n      case \"bottom\":\r\n        return \"rotate(90deg)\";\r\n      case \"left\":\r\n        return \"rotate(-180deg)\";\r\n    }\r\n  }};\r\n\r\n  grid-area: ${(props) => {\r\n    switch (props.direction) {\r\n      case \"top\":\r\n        return \"arrow_top;\";\r\n      case \"bottom\":\r\n        return \"arrow_bottom\";\r\n      case \"left\":\r\n        return \"arrow_left\";\r\n      case \"right\":\r\n        return \"arrow_right\";\r\n    }\r\n  }};\r\n`;\r\n\r\nconst ArrowContainer = styled.div`\r\n  display: grid;\r\n  grid-template-areas:\r\n    \". arrow_top .\"\r\n    \"arrow_left . arrow_right \"\r\n    \". arrow_bottom . \";\r\n  width: 100px;\r\n  height: 100px;\r\n  & > * {\r\n    padding: 6px;\r\n    box-sizing: border-box;\r\n    background-color: white;\r\n  }\r\n`;\r\n\r\nexport const MoveControls = () => {\r\n  const dispatch = useDispatch();\r\n\r\n  const renderArrow = (direction: MoveDirection) => {\r\n    return (\r\n      <Arrow\r\n        direction={direction}\r\n        onClick={() => {\r\n          dispatch({ type: \"moveControlsClicked\", payload: direction });\r\n        }}\r\n      >\r\n        &gt;\r\n      </Arrow>\r\n    );\r\n  };\r\n\r\n  return (\r\n    <ArrowContainer>\r\n      {renderArrow(\"top\")}\r\n      {renderArrow(\"right\")}\r\n      {renderArrow(\"left\")}\r\n      {renderArrow(\"bottom\")}\r\n    </ArrowContainer>\r\n  );\r\n};\r\n","export const ItemDragTypes = {\r\n  PLAYER: \"player\",\r\n  ENEMY: \"enemy\",\r\n};\r\n","import { FC } from \"react\";\r\nimport { useDrop } from \"react-dnd\";\r\nimport { useDispatch } from \"react-redux\";\r\nimport styled from \"styled-components\";\r\n\r\nimport { PlayGridMode } from \"../business/types\";\r\nimport { ItemDragTypes } from \"../shared/ItemTypes\";\r\n\r\ntype CellAppearance = {\r\n  needHighlightning?: boolean;\r\n  mode: PlayGridMode;\r\n};\r\n\r\ntype CellItemType = {\r\n  hor: string;\r\n  vert: string;\r\n\r\n  children: React.ReactNode;\r\n} & CellAppearance;\r\n\r\nconst StyledCellItem = styled.div<CellAppearance & { isOver: boolean }>`\r\n  display: flex;\r\n  position: relative;\r\n  box-sizing: border-box;\r\n\r\n  font-size: 14px;\r\n  text-align: right;\r\n  width: 50px;\r\n  height: 50px;\r\n  color: lightgrey;\r\n\r\n  border: ${({ mode }) => {\r\n    if (mode === \"cssStyle\") {\r\n      return \"1px solid lightgray\";\r\n    }\r\n  }};\r\n\r\n  background-color: ${({ needHighlightning, isOver }) => {\r\n    if (needHighlightning) {\r\n      return isOver ? \"yellow\" : \"rgb(55 163 0 / 52%);\";\r\n    }\r\n  }};\r\n`;\r\n\r\nexport const CellItem: FC<CellItemType> = ({\r\n  needHighlightning,\r\n  mode,\r\n  children,\r\n  hor,\r\n  vert,\r\n}) => {\r\n  const dispatch = useDispatch();\r\n\r\n  const [{ isOver }, drop] = useDrop(() => ({\r\n    accept: ItemDragTypes.PLAYER,\r\n\r\n    drop: () =>\r\n      dispatch({\r\n        type: \"playerWasMoved\",\r\n        payload: {\r\n          hor,\r\n          vert,\r\n        },\r\n      }),\r\n    collect: (monitor) => ({\r\n      isOver: !!monitor.isOver(),\r\n    }),\r\n    hover: () => {\r\n      // console.log(\"hover\", hor, vert);\r\n    },\r\n  }));\r\n\r\n  return (\r\n    <>\r\n      <StyledCellItem\r\n        ref={drop}\r\n        needHighlightning={needHighlightning}\r\n        mode={mode}\r\n        isOver={isOver}\r\n      >\r\n        {children}\r\n      </StyledCellItem>\r\n    </>\r\n  );\r\n};\r\n","import { MoveDirection } from \"../../types\";\r\n\r\n/**\r\n * Returns new coordinate of player.\r\n * @param currentCoord A string of current coordinate.\r\n * @param direction  A string of direction.\r\n * @returns A string with new coordinate.\r\n */\r\n\r\nexport const getNextPlayerCoord = (\r\n  currentCoord: string,\r\n  direction: MoveDirection\r\n) => {\r\n  \r\n  const [currPlayerHor, currPlayerVert] = currentCoord.split(\".\");\r\n  const nextPlayerVert = parseInt(currPlayerVert) + 1;\r\n  const nextPlayerHor = parseInt(currPlayerHor) + 1;\r\n  const prevPlayerVert = parseInt(currPlayerVert) - 1;\r\n  const prevPlayerHor = parseInt(currPlayerHor) - 1;\r\n\r\n  switch (direction) {\r\n    case \"top\": {\r\n      return `${currPlayerHor}.${nextPlayerVert}`;\r\n    }\r\n\r\n    case \"bottom\": {\r\n      return `${currPlayerHor}.${prevPlayerVert}`;\r\n    }\r\n\r\n    case \"left\": {\r\n      return `${prevPlayerHor}.${currPlayerVert}`;\r\n    }\r\n\r\n    case \"right\": {\r\n      return `${nextPlayerHor}.${currPlayerVert}`;\r\n    }\r\n\r\n    default:\r\n      return `${currPlayerHor}.${currPlayerVert}`;\r\n  }\r\n};\r\n","import {\r\n  AvailableCellListType,\r\n  GameField,\r\n  MoveDirectionList,\r\n} from \"../../types\";\r\nimport { getNextPlayerCoord } from \"./getNextPlayerCoord\";\r\n\r\nexport const MOVE_DIRECTION_LIST: MoveDirectionList = [\r\n  \"top\",\r\n  \"right\",\r\n  \"bottom\",\r\n  \"left\",\r\n];\r\n\r\n/**\r\n * Returns the coordinates of neighboribgCells that lying in the GameField.\r\n */\r\nexport const getNeighboringCellList = (\r\n  prevPlayerCoord: string,\r\n  gameField: GameField\r\n): AvailableCellListType => {\r\n  const coordNeighboringCells: AvailableCellListType = MOVE_DIRECTION_LIST.map(\r\n    (directionItem) => {\r\n      return {\r\n        direction: directionItem,\r\n        coord: getNextPlayerCoord(prevPlayerCoord, directionItem),\r\n      };\r\n    }\r\n  );\r\n\r\n  /**\r\n   * Returns the coordinates that lying in the GameField.\r\n   */\r\n  const existingInGameFieldCells: AvailableCellListType =\r\n    coordNeighboringCells.filter((cellItem) => {\r\n      const { coord } = cellItem;\r\n      return gameField.values[coord];\r\n    });\r\n\r\n  return existingInGameFieldCells;\r\n};\r\n","export default __webpack_public_path__ + \"static/media/door2.026ae7fc.png\";","export default __webpack_public_path__ + \"static/media/window2.5b58d59d.png\";","import { useDispatch, useSelector } from \"react-redux\";\r\n\r\nimport styled from \"styled-components\";\r\n\r\nimport { getNeighboringCellList } from \"../../business/phases/common/getNeighboringCellList\";\r\n\r\nimport closedDoor from \"../../assets/door2.png\";\r\nimport closedWindow from \"../../assets/window2.png\";\r\nimport door from \"../../assets/door.png\";\r\nimport window from \"../../assets/window.png\";\r\n\r\nimport {\r\n  State,\r\n  MoveDirection,\r\n  BarrierItem,\r\n  AvailableCellListType,\r\n  GameField,\r\n  GameState,\r\n  PlayerListType,\r\n  CellType,\r\n  AvailableCellType,\r\n  PlayGridMode,\r\n} from \"../../business/types\";\r\nimport { FC } from \"react\";\r\n\r\ntype WallType = {\r\n  barrierItem?: BarrierItem;\r\n  //TODO: поправить тип?\r\n  highlightningList: (MoveDirection | null)[] | null;\r\n  onClick: Function;\r\n};\r\n\r\ntype BarrierCoord = {\r\n  orderIndex: string;\r\n  mode: PlayGridMode;\r\n};\r\n\r\nconst CommonWall = styled.div<WallType>`\r\n  pointer-events: ${(props) => {\r\n    if (\r\n      props.barrierItem &&\r\n      props.barrierItem.name !== \"wall\" &&\r\n      props.barrierItem.isOpen\r\n    ) {\r\n      const needHighlightning = props.highlightningList?.find((item) => {\r\n        return item === \"bottom\" || \"left\";\r\n      });\r\n      if (needHighlightning) {\r\n        return \"defaulr\";\r\n      } else {\r\n        return \"none\";\r\n      }\r\n    } else {\r\n      return \"none\";\r\n    }\r\n  }};\r\n\r\n  cursor: ${(props) => {\r\n    switch (props.barrierItem?.name) {\r\n      case \"wall\": {\r\n        return \"default\";\r\n      }\r\n      case \"door\": {\r\n        return \"pointer\";\r\n      }\r\n      case \"window\": {\r\n        return \"pointer\";\r\n      }\r\n      default:\r\n        return \"default\";\r\n    }\r\n  }};\r\n\r\n  &:before {\r\n    content: \"\";\r\n    position: absolute;\r\n    width: 50px;\r\n    height: 50px;\r\n    bottom: 0px;\r\n    z-index: 5;\r\n  }\r\n`;\r\n\r\nconst WallImage = styled(CommonWall)<WallType>`\r\n  transform: ${(props) => {\r\n    switch (props.barrierItem?.direction) {\r\n      case \"left\": {\r\n        return \"rotate(90deg)\";\r\n      }\r\n      default: {\r\n        return \"null\";\r\n      }\r\n    }\r\n  }};\r\n\r\n  &:before {\r\n    pointer-events: none;\r\n    bottom: ${(props) => {\r\n      switch (props.barrierItem?.direction) {\r\n        case \"bottom\": {\r\n          return \"-30px\";\r\n        }\r\n        case \"left\": {\r\n          return \"-55px\";\r\n        }\r\n        default: {\r\n          return \"null\";\r\n        }\r\n      }\r\n    }};\r\n\r\n    left: ${(props) => {\r\n      switch (props.barrierItem?.direction) {\r\n        case \"left\": {\r\n          return \"-25px\";\r\n        }\r\n        default: {\r\n          return \"null\";\r\n        }\r\n      }\r\n    }};\r\n\r\n    background-size: 44px;\r\n    background-image: ${(props) => {\r\n      switch (\r\n        props.barrierItem &&\r\n        props.barrierItem.name !== \"wall\" &&\r\n        props.barrierItem.isOpen\r\n      ) {\r\n        case true: {\r\n          switch (props.barrierItem?.name) {\r\n            case \"door\": {\r\n              return `url(${door})`;\r\n            }\r\n            case \"window\": {\r\n              return `url(${window})`;\r\n            }\r\n            default: {\r\n              return \"unset\";\r\n            }\r\n          }\r\n        }\r\n        case false: {\r\n          switch (props.barrierItem?.name) {\r\n            case \"door\": {\r\n              return `url(${closedDoor})`;\r\n            }\r\n            case \"window\": {\r\n              return `url(${closedWindow})`;\r\n            }\r\n            default: {\r\n              return \"unset\";\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }};\r\n  }\r\n\r\n  &:after {\r\n    content: \"\";\r\n    z-index: 5;\r\n    position: absolute;\r\n    width: 50px;\r\n    height: 50px;\r\n    z-index: 5;\r\n\r\n    top: ${(props) => {\r\n      if (props.barrierItem?.direction === \"left\") {\r\n        return \"14px\";\r\n      }\r\n    }};\r\n\r\n    width: ${(props) => {\r\n      if (props.barrierItem?.direction === \"left\") {\r\n        return \"50px\";\r\n      }\r\n    }};\r\n\r\n    height: ${(props) => {\r\n      if (\r\n        props.barrierItem?.direction === \"bottom\" ||\r\n        props.barrierItem?.direction === \"left\"\r\n      ) {\r\n        return \"20px\";\r\n      }\r\n    }};\r\n\r\n    bottom: ${(props) => {\r\n      if (props.barrierItem?.direction === \"bottom\") {\r\n        return \"-10px\";\r\n      }\r\n    }};\r\n\r\n    left: ${(props) => {\r\n      if (props.barrierItem?.direction === \"left\") {\r\n        return \"-25px\";\r\n      }\r\n    }};\r\n\r\n    background-color: ${(props) => {\r\n      if (\r\n        props.barrierItem &&\r\n        props.barrierItem.name !== \"wall\" &&\r\n        props.barrierItem.isOpen\r\n      ) {\r\n        const needHighlightning = props.highlightningList?.find((item) => {\r\n          return item === \"bottom\" || \"left\";\r\n        });\r\n        if (needHighlightning) {\r\n          return \"#c1fe2f6b\";\r\n        } else {\r\n          return \"none\";\r\n        }\r\n      }\r\n    }};\r\n  }\r\n\r\n  &:hover:after {\r\n    background-color: ${(props) => {\r\n      if (\r\n        props.barrierItem &&\r\n        props.barrierItem.name !== \"wall\" &&\r\n        props.barrierItem.isOpen\r\n      ) {\r\n        const needHighlightning = props.highlightningList?.find((item) => {\r\n          return item === \"bottom\" || \"left\";\r\n        });\r\n        if (needHighlightning) {\r\n          return \"#6cfe2fde\";\r\n        } else {\r\n          return \"none\";\r\n        }\r\n      }\r\n    }};\r\n  }\r\n`;\r\n\r\nconst Wall = styled(CommonWall)<WallType>`\r\n  &:before {\r\n    pointer-events: none;\r\n    height: ${(props) => {\r\n      if (props.barrierItem?.direction === \"bottom\") {\r\n        if (\r\n          props.barrierItem &&\r\n          props.barrierItem.name !== \"wall\" &&\r\n          props.barrierItem.isOpen === false\r\n        ) {\r\n          return \"10px\";\r\n        } else {\r\n          switch (props.barrierItem.name) {\r\n            case \"wall\": {\r\n              return \"5px\";\r\n            }\r\n            case \"door\": {\r\n              return \"3px\";\r\n            }\r\n            case \"window\": {\r\n              return \"3px\";\r\n            }\r\n            default:\r\n              return \"0px\";\r\n          }\r\n        }\r\n      } else if (\r\n        props.barrierItem &&\r\n        props.barrierItem.direction === \"left\" &&\r\n        props.barrierItem.name !== null\r\n      ) {\r\n        return \"50px\";\r\n        //it is needed for now for pretty  wall painting\r\n      } else if (props.barrierItem && props.barrierItem.name === null) {\r\n        return \"5px\";\r\n      } else {\r\n        return \"0px\";\r\n      }\r\n    }};\r\n\r\n    width: ${(props) => {\r\n      if (props.barrierItem?.direction === \"left\") {\r\n        if (\r\n          props.barrierItem &&\r\n          props.barrierItem.name !== \"wall\" &&\r\n          props.barrierItem.isOpen === false\r\n        ) {\r\n          return \"10px\";\r\n        } else {\r\n          switch (props.barrierItem.name) {\r\n            case \"wall\": {\r\n              return \"5px \";\r\n            }\r\n            case \"door\": {\r\n              return \"3px\";\r\n            }\r\n            case \"window\": {\r\n              return \"3px\";\r\n            }\r\n            default:\r\n              return \"5px\";\r\n          }\r\n        }\r\n      } else {\r\n        return \"none\";\r\n      }\r\n    }};\r\n\r\n    background-color: ${(props) => {\r\n      if (\r\n        (props.barrierItem && props.barrierItem.name === \"wall\") ||\r\n        (props.barrierItem && props.barrierItem.isOpen)\r\n      ) {\r\n        const needHighlightning = props.highlightningList?.find((item) => {\r\n          return item === \"bottom\" || \"left\";\r\n        });\r\n        switch (props.barrierItem.name) {\r\n          case \"wall\": {\r\n            return \"#f09308;\";\r\n          }\r\n          case \"door\": {\r\n            if (needHighlightning) {\r\n              return \"#78ff2d\";\r\n            } else {\r\n              return \" #584324;\";\r\n            }\r\n          }\r\n          case \"window\": {\r\n            if (needHighlightning) {\r\n              return \"#78ff2d\";\r\n            } else {\r\n              return \" #a3cdd8;\";\r\n            }\r\n          }\r\n          default:\r\n            return \"#f09308\";\r\n        }\r\n      } else if (props.barrierItem?.isOpen === false) {\r\n        return \"#66615d;\";\r\n      } else {\r\n        return \"none\";\r\n      }\r\n    }};\r\n  }\r\n\r\n  &:after {\r\n    content: \"\";\r\n    z-index: 5;\r\n    position: absolute;\r\n    width: 50px;\r\n    height: 50px;\r\n    z-index: 5;\r\n\r\n    top: ${(props) => {\r\n      if (props.barrierItem?.direction === \"left\") {\r\n        return \"0\";\r\n      }\r\n    }};\r\n\r\n    height: ${(props) => {\r\n      if (props.barrierItem?.direction === \"bottom\" && props.barrierItem) {\r\n        return \"20px\";\r\n      }\r\n    }};\r\n\r\n    width: ${(props) => {\r\n      if (props.barrierItem?.direction === \"left\") {\r\n        return \"20px\";\r\n      }\r\n    }};\r\n\r\n    bottom: ${(props) => {\r\n      if (props.barrierItem?.direction === \"bottom\") {\r\n        return \"-10px\";\r\n      }\r\n    }};\r\n\r\n    left: ${(props) => {\r\n      if (props.barrierItem?.direction === \"left\") {\r\n        return \"-10px\";\r\n      }\r\n    }};\r\n\r\n    background-color: ${(props) => {\r\n      if (\r\n        props.barrierItem &&\r\n        props.barrierItem.name !== \"wall\" &&\r\n        props.barrierItem.isOpen\r\n      ) {\r\n        const needHighlightning = props.highlightningList?.find((item) => {\r\n          return item === \"bottom\" || \"left\";\r\n        });\r\n        if (needHighlightning) {\r\n          return \"#79fe2f42\";\r\n        } else {\r\n          return \"none\";\r\n        }\r\n      }\r\n    }};\r\n  }\r\n`;\r\n\r\n//TODO: слишком много сложной логики лежит в компоненте, вынести наверх?\r\nexport const Barrier: FC<BarrierCoord> = ({ orderIndex, mode }) => {\r\n  const dispatch = useDispatch();\r\n\r\n  const needApplyBoardCard = useSelector((state: State) => {\r\n    const isCardApplyPhase = state.gameState.type === \"gameStarted.applyCard\";\r\n    const boardCardActive =\r\n      state.playerList[state.activePlayerNumber]?.inventory.cardSelected ===\r\n      \"boards\";\r\n\r\n    return isCardApplyPhase && boardCardActive;\r\n  });\r\n\r\n  // const gameState = useSelector((state: State) => state.gameState);\r\n  const gameField = useSelector((state: State) => state.gameField);\r\n  const playerList = useSelector((state: State) => state.playerList);\r\n  const activePlayerNumber = useSelector(\r\n    (state: State) => state.activePlayerNumber\r\n  );\r\n\r\n  const cellValues = gameField.values[orderIndex];\r\n  const isCurrPlayerAlive = playerList[activePlayerNumber] ? true : false;\r\n\r\n  const getWallItem = (\r\n    barrier: BarrierItem,\r\n    mode: PlayGridMode,\r\n    highlightningList: any,\r\n    onClickHandler: any\r\n  ) => {\r\n    switch (mode) {\r\n      case \"cssStyle\": {\r\n        return (\r\n          <Wall\r\n            key={barrier.direction}\r\n            barrierItem={barrier}\r\n            highlightningList={highlightningList ? highlightningList() : null}\r\n            onClick={() => onClickHandler()}\r\n          ></Wall>\r\n        );\r\n      }\r\n      case \"image\": {\r\n        return (\r\n          <WallImage\r\n            key={barrier.direction}\r\n            barrierItem={barrier}\r\n            highlightningList={highlightningList ? highlightningList() : null}\r\n            onClick={() => onClickHandler()}\r\n          ></WallImage>\r\n        );\r\n      }\r\n      default: {\r\n        return null;\r\n      }\r\n    }\r\n  };\r\n\r\n  switch (cellValues.name) {\r\n    case \"commonCell\": {\r\n      const barrierList = cellValues.barrierList?.map((barrier) => {\r\n        switch (isCurrPlayerAlive) {\r\n          case false: {\r\n            return getWallItem(barrier, mode, null, null);\r\n          }\r\n\r\n          case true: {\r\n            const currPlayerCoord = playerList[activePlayerNumber].coord;\r\n\r\n            const neighboringCellList = getNeighboringCellList(\r\n              currPlayerCoord,\r\n              gameField\r\n            );\r\n\r\n            const neighboringCellListCoord = neighboringCellList.map(\r\n              (cellItem) => {\r\n                return cellItem.coord;\r\n              }\r\n            );\r\n\r\n            const checkCellListCoord =\r\n              neighboringCellListCoord.concat(currPlayerCoord);\r\n\r\n            const needCheckHighlightning = checkCellListCoord.find(\r\n              (coord) => orderIndex === coord\r\n            );\r\n\r\n            const highlightningList = getHighlightningList(\r\n              neighboringCellList,\r\n              gameField,\r\n              currPlayerCoord,\r\n              needApplyBoardCard\r\n            );\r\n\r\n            const getHighlightningListItem = () => {\r\n              return needCheckHighlightning\r\n                ? getHighlightningDirection(\r\n                    highlightningList,\r\n                    orderIndex,\r\n                    barrier.direction\r\n                  )\r\n                : null;\r\n            };\r\n\r\n            const onClickHandler = () => {\r\n              const canCloseHole = highlightningList.find((cellType) => {\r\n                return (\r\n                  cellType?.coord === orderIndex &&\r\n                  cellType?.direction === barrier.direction &&\r\n                  barrier.name !== \"wall\" &&\r\n                  barrier.isOpen === true\r\n                );\r\n              })\r\n                ? true\r\n                : false;\r\n              if (canCloseHole) {\r\n                dispatch({\r\n                  type: \"req-fillHole\",\r\n                  payload: {\r\n                    coord: orderIndex,\r\n                    direction: barrier.direction,\r\n                  },\r\n                });\r\n              } else {\r\n                return null;\r\n              }\r\n            };\r\n\r\n            return getWallItem(\r\n              barrier,\r\n              mode,\r\n              getHighlightningListItem,\r\n              onClickHandler\r\n            );\r\n          }\r\n\r\n          default: {\r\n            return null;\r\n          }\r\n        }\r\n      });\r\n      return <>{barrierList}</>;\r\n    }\r\n    default: {\r\n      return null;\r\n    }\r\n  }\r\n};\r\n\r\nconst getHighlightningDirection = (\r\n  highlightningList: (AvailableCellType | null)[],\r\n  orderIndex: string,\r\n  direction: MoveDirection\r\n) => {\r\n  const currList = highlightningList.filter((cellItem) => {\r\n    return cellItem?.coord === orderIndex && cellItem?.direction === direction;\r\n  });\r\n\r\n  const structuredList = currList.map((cellItem) => {\r\n    if (cellItem) {\r\n      const { direction } = cellItem;\r\n      return direction;\r\n    } else {\r\n      return null;\r\n    }\r\n  });\r\n\r\n  return structuredList;\r\n};\r\n\r\n/**\r\n * Check the neifhboring of that coord.\r\n * Have they door or window\r\n */\r\nconst getHighlightningList = (\r\n  neighboringCellList: AvailableCellListType,\r\n  gameField: GameField,\r\n  currCoord: string,\r\n  needApplyBoardCard: boolean\r\n) => {\r\n  const currCell = gameField.values[currCoord];\r\n\r\n  const availableCellList = neighboringCellList\r\n    .map((cellItem) => {\r\n      const { direction, coord } = cellItem;\r\n      const currCellHasHole = checkCellOnHole(currCell, direction);\r\n      const nextCell = gameField.values[coord];\r\n      const oppositeDirection = getOppositeDirection(direction);\r\n      const nextCellHasHole = checkCellOnHole(nextCell, oppositeDirection);\r\n      if (currCellHasHole) {\r\n        const cellItemWithHole: AvailableCellType = {\r\n          direction,\r\n          coord: currCoord,\r\n        };\r\n\r\n        return cellItemWithHole;\r\n      } else if (nextCellHasHole) {\r\n        const cellItemWithHole: AvailableCellType = {\r\n          direction: oppositeDirection,\r\n          coord,\r\n        };\r\n        return cellItemWithHole;\r\n      } else {\r\n        return null;\r\n      }\r\n    })\r\n    .filter((availableCell) => availableCell !== null);\r\n\r\n  if (needApplyBoardCard) {\r\n    return availableCellList;\r\n  } else {\r\n    return [];\r\n  }\r\n};\r\n\r\nconst checkCellOnHole = (cell: CellType, direction: MoveDirection) => {\r\n  if (cell.name === \"commonCell\") {\r\n    if (direction === \"left\" || direction === \"bottom\") {\r\n      const cellHasWindow = cell.barrierList?.find(\r\n        (barrier) => barrier.name === \"window\"\r\n      )\r\n        ? true\r\n        : false;\r\n      const cellHasDoor = cell.barrierList?.find(\r\n        (barrier) => barrier.name === \"door\"\r\n      )\r\n        ? true\r\n        : false;\r\n      const cellHasHole = cellHasWindow || cellHasDoor;\r\n      return cellHasHole;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n  return false;\r\n};\r\n\r\nconst getOppositeDirection = (direction: MoveDirection): MoveDirection => {\r\n  switch (direction) {\r\n    case \"top\": {\r\n      return \"bottom\";\r\n    }\r\n    case \"bottom\": {\r\n      return \"top\";\r\n    }\r\n    case \"left\": {\r\n      return \"right\";\r\n    }\r\n    case \"right\": {\r\n      return \"left\";\r\n    }\r\n  }\r\n};\r\n","export default \"data:image/png;base64,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RBkBABBlBABAlBEAAFFGAABEGQEAEGUEAECUEQAAUUYAAEQZAQAQZQQAQJQRAABRRgAARBkBABBlBABAlBEAAFFGAABEGQEAEGUEAECUEQAAUUYAAEQZAQAQZQQAQJQRAABRRgAARBkBABBlBABAlBEAAFFGAABEGQEAEGUEAECUEQAAUUYAAEQZAQAQZQQAQJQRAABRRgAARBkBABBlBABAlBEAAFFGAABEGQEAEGUEAECUEQAAUUYAAEQZAQAQZQQAQJQRAABRRgAARBkBABBlBABAlBEAAFFGAABEGQEAEGUEAECUEQAAUUYAAEQZAQAQZQQAQJQRAABRRgAARBkBABBlBABAlBEAAFFGAABEGQEAEGUEAECUEQAAUUYAAEQZAQAQZQQAQJQRAABRRgAARBkBABBlBABAlBEAAFFGAABEGQEAEGUEAECUEQAAUUYAAEQZAQAQZQQAQJQRAABRRgAARBkBABBlBABAlBEAAFFGAABEGQEAEGUEAECUEQAAUUYAAEQZAQAQZQQAQJQRAABRRgAARBkBABBlBABAlBEAAFFGAABEGQEAEGUEAECUEQAAUUYAAEQZAQAQZQQAQJQRAABRRgAARBkBABBlBABAlBEAAFFGAABEGQEAEGUEAECUEQAAUUYAAEQZAQAQZQQAQJQRAABRRgAARBkBABBlBABAlBEAAEXb/gfqHj58J38MQgAAAABJRU5ErkJggg==\"","export default \"data:image/png;base64,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AABRRgAARBkBABBlBABAlBEAAFFGAABEGQEAEGUEAECUEQAAUUYAAEQZAQAQZQQAQJQRAABRRgAARBkBABBlBABAlBEAAFFGAABEGQEAEGUEAECUEQAAUUYAAEQZAQAQZQQAQJQRAABRRgAARBkBABBlBABAlBEAAFFGAABEGQEAEGUEAECUEQAAUUYAAEQZAQAQZQQAQJQRAABRRgAARBkBABBlBABAlBEAAFFGAABEGQEAEGUEAECUEQAAUUYAAEQZAQAQZQQAQJQRAABRRgAARBkBABBlBABAlBEAAFFGAABEGQEAEGUEAECUEQAAUUYAAEQZAQAQZQQAQJQRAABRRgAARBkBABBlBABAlBEAAFFGAABEGQEAEGUEAECUEQAAUUYAAEQZAQAQZQQAQJQRAABRRgAARBkBABBlBABAlBEAAFFGAABEGQEAEGUEAECUEQAAUUYAAEQZAQAQZQQAQJQRAABRRgAARBkBABBlBABAlBEAAFFGAABEGQEAEGUEAECUEQAAUUYAAEQZAQAQZQQAQJQRAABRRgAARBkBABBlBABAlBEAAFFGAABEGQEAEGUEAECUEQAAUUYAAEQZAQAQZQQAQJQRAABRRgAARBkBABBlBABAlBEAAFFGAABEGQEAEGUEAECUEQAAUUYAAEQZAQAQZQQAQJQRAABRRgAARBkBABBlBABA0bb/AQYXRF3lFXNFAAAAAElFTkSuQmCC\"","import { useEffect, useReducer, useRef } from \"react\";\r\nimport { useSelector } from \"react-redux\";\r\n\r\nimport { State } from \"../types\";\r\n\r\ntype PhaseType = \"waiting\" | \"running\" | \"ended\";\r\ntype EffectType = null | \"startEffect\" | \"stopEffect\";\r\n\r\ntype ActionType = { type: \"start\" } | { type: \"clearEffect\" };\r\n\r\ntype TimerControlledType = {\r\n  timeState: {\r\n    timeMark: number;\r\n    initialTimeMark: number;\r\n  };\r\n  phase: PhaseType;\r\n  effect: EffectType;\r\n};\r\n\r\n// maxTime- in second\r\nexport function useOpenCardAnimation({\r\n  needRun,\r\n  maxTime,\r\n  onTimerEnd,\r\n}: {\r\n  needRun: boolean;\r\n  maxTime: number;\r\n  onTimerEnd: () => void;\r\n}) {\r\n  const doEffect = useSelector((state: State) => state.doEffect);\r\n  const cardRef = {\r\n    cardContainerRef: useRef<HTMLDivElement>(null),\r\n    cardFrontRef: useRef<HTMLDivElement>(null),\r\n  };\r\n\r\n  const initialTimeState = {\r\n    timeMark: 0,\r\n    initialTimeMark: 0,\r\n  };\r\n\r\n  const initialState: TimerControlledType = {\r\n    timeState: initialTimeState,\r\n    phase: \"waiting\",\r\n    effect: null,\r\n  };\r\n\r\n  const reducer = (\r\n    state: TimerControlledType,\r\n    action: ActionType\r\n  ): TimerControlledType => {\r\n    switch (action.type) {\r\n      case \"start\": {\r\n        if (!state.effect) {\r\n          const newTimeState = {\r\n            ...state.timeState,\r\n            timeMark: new Date().getTime(),\r\n            initialTimeMark: new Date().getTime(),\r\n          };\r\n          return { ...state, timeState: newTimeState, effect: \"startEffect\" };\r\n        } else {\r\n          return state;\r\n        }\r\n      }\r\n\r\n      case \"clearEffect\": {\r\n        return { ...state, effect: \"stopEffect\" };\r\n      }\r\n      default: {\r\n        return state;\r\n      }\r\n    }\r\n  };\r\n\r\n  const [state, dispatch] = useReducer(reducer, initialState);\r\n\r\n  useEffect(\r\n    function openCardAnimation() {\r\n      switch (doEffect?.type) {\r\n        case \"!openCard\": {\r\n          if (needRun) {\r\n            //нужно запустить анимацию\r\n\r\n            dispatch({ type: \"start\" });\r\n          }\r\n\r\n          break;\r\n        }\r\n        default: {\r\n          break;\r\n        }\r\n      }\r\n    },\r\n    //eslint-disable-next-line\r\n    [doEffect, needRun]\r\n  );\r\n\r\n  const getTimerValue = (currTime: number) => {\r\n    const timeDiff = Math.floor(\r\n      (currTime - state.timeState?.initialTimeMark) / 1000\r\n    );\r\n    const timeCurr = maxTime - timeDiff;\r\n    return timeCurr >= 0 ? timeCurr : 0;\r\n  };\r\n\r\n  useEffect(() => {\r\n    //ра3 в секунду проверяем не вышел ли таймер\r\n    if (state.effect === \"startEffect\") {\r\n      const intervalId = setInterval(() => {\r\n        const currentTime = getTimerValue(new Date().getTime());\r\n\r\n        if (cardRef.cardContainerRef.current && cardRef.cardFrontRef.current) {\r\n          cardRef.cardContainerRef.current.style.transform = \"rotateY(180deg)\";\r\n          cardRef.cardContainerRef.current.style.transition = `transform ${maxTime}s`;\r\n          cardRef.cardContainerRef.current.style.color = \"red\";\r\n\r\n          cardRef.cardFrontRef.current.style.transform = \"rotateY(180deg)\";\r\n        }\r\n\r\n        if (currentTime <= 0) {\r\n          clearInterval(intervalId);\r\n          dispatch({ type: \"clearEffect\" });\r\n        }\r\n      }, 1000);\r\n\r\n      return () => {\r\n        clearInterval(intervalId);\r\n      };\r\n    } else if (state.effect === \"stopEffect\") {\r\n      onTimerEnd();\r\n    }\r\n\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, [state.effect]);\r\n\r\n  return { cardRef };\r\n}\r\n","export default __webpack_public_path__ + \"static/media/brain_4.c48babfd.png\";","import { css } from \"styled-components\";\r\nimport img from \"./brain_4.png\";\r\n\r\nexport const StyledCommonCard = css`\r\n  position: absolute;\r\n  width: 50px;\r\n  height: 50px;\r\n  /* background-image: url(${img}); */\r\n  background-size: 44px;\r\n  background-repeat: no-repeat;\r\n  background-position: 3px;\r\n`;\r\n","export default __webpack_public_path__ + \"static/media/health.d3aa03e8.png\";","import styled from \"styled-components\";\r\nimport { StyledCommonCard } from \"../common/CommonCard\";\r\nimport { CardAppearance } from \"../../business/types\";\r\nimport img from \"./health.png\";\r\nimport brainImg from \"../common/CommonCard/brain_4.png\";\r\nimport { FC } from \"react\";\r\n\r\ntype WeaponApperanceType = {\r\n  apperance?: \"closed\" | \"open\";\r\n  ref: any;\r\n};\r\n\r\nconst CardContainer = styled.div<WeaponApperanceType>`\r\n  width: 50px;\r\n  height: 50px;\r\n  position: relative;\r\n  transform-style: preserve-3d;\r\n`;\r\n\r\nconst CardFace = styled.div`\r\n  position: absolute;\r\n  height: 100%;\r\n  width: 100%;\r\n  backface-visibility: hidden;\r\n`;\r\n\r\nconst CardFront = styled(CardFace)`\r\n  ${StyledCommonCard}\r\n  background-color: unset;\r\n  background-image: url(${img});\r\n  border-color: gray;\r\n`;\r\n\r\nconst CardBack = styled(CardFace)<{ apperance: \"closed\" | \"open\" }>`\r\n  ${StyledCommonCard}\r\n  background-image: url(${brainImg});\r\n  display: ${({ apperance }) => {\r\n    if (apperance === \"open\") {\r\n      return \"none\";\r\n    }\r\n  }};\r\n`;\r\n\r\nexport const HealthCard: FC<{\r\n  apperance: CardAppearance;\r\n  refList: {\r\n    cardContainerRef: React.RefObject<HTMLDivElement>;\r\n    cardFrontRef: React.RefObject<HTMLDivElement>;\r\n  };\r\n}> = ({ apperance, refList }) => {\r\n  return (\r\n    <CardContainer ref={refList.cardContainerRef}>\r\n      <CardFront ref={refList.cardFrontRef} />\r\n      <CardBack apperance={apperance} />\r\n    </CardContainer>\r\n  );\r\n};\r\n","export default __webpack_public_path__ + \"static/media/player.78f136ce.png\";","export default __webpack_public_path__ + \"static/media/player2.36663427.png\";","export default __webpack_public_path__ + \"static/media/player3.082d8752.png\";","export default __webpack_public_path__ + \"static/media/player4.c9a08f56.png\";","import styled from \"styled-components\";\r\n\r\nexport const StyledCommonPlayerCard = styled.div<{\r\n  image: string;\r\n  isCurrent: boolean;\r\n}>`\r\n  width: 50px;\r\n  height: 50px;\r\n  margin: 0px;\r\n  text-align: center;\r\n  padding: 2px;\r\n  box-sizing: border-box;\r\n  cursor: default;\r\n  background-repeat: no-repeat;\r\n  background-position: 0px;\r\n  background-size: 44px;\r\n  background-position: 3px;\r\n\r\n  background-image: ${(props) => {\r\n    return `url(${props.image})`;\r\n  }};\r\n\r\n  &:before {\r\n    content: \"\";\r\n    position: absolute;\r\n    width: 24px;\r\n    height: 24px;\r\n    border-radius: 1px;\r\n\r\n    border: ${(props) => {\r\n      if (props.isCurrent) {\r\n        return \"5px solid #8834b8\";\r\n      }\r\n    }};\r\n\r\n    pointer-events: none;\r\n    opacity: 0.5;\r\n    padding: 4px;\r\n    left: 4px;\r\n    top: 4px;\r\n  }\r\n`;\r\n","import { ItemDragTypes } from \"../../../shared/ItemTypes\";\r\nimport styled from \"styled-components\";\r\n\r\nimport type { XYCoord } from \"react-dnd\";\r\nimport { useDragLayer } from \"react-dnd\";\r\nimport { StyledCommonPlayerCard } from \"./StyledCommonPlayerCard\";\r\nimport ReactDOM from \"react-dom\";\r\n\r\nconst StyledPreviewWrap = styled.div`\r\n  position: absolute !important;\r\n  pointer-events: none;\r\n  z-index: 100;\r\n  left: 0;\r\n  top: 0;\r\n  width: 100%;\r\n  height: 100%;\r\n`;\r\n\r\ntype PortalType = {\r\n  coordX: string;\r\n  coordY: string;\r\n};\r\n\r\nconst PLayersPortal = styled.div<PortalType>`\r\n  position: relative;\r\n  display: flex;\r\n  left: ${(props) => {\r\n    return `${Number(props.coordX) * 50}px`;\r\n  }};\r\n\r\n  bottom: ${(props) => {\r\n    return `${Number(props.coordY) * 50 + 50}px`;\r\n  }};\r\n`;\r\n\r\nexport const PreviewDrag = ({ isCurrent, image, coordX, coordY }: any) => {\r\n  // const [gameStateType] = useSelector((state: State) => [state.gameState.type]);\r\n  const { isDragging, initialOffset, currentOffset, itemType } = useDragLayer(\r\n    (monitor) => ({\r\n      /*       item: monitor.getItem(), */\r\n      itemType: monitor.getItemType(),\r\n      isDragging: monitor.isDragging(),\r\n      initialOffset: monitor.getInitialSourceClientOffset(),\r\n      currentOffset: monitor.getDifferenceFromInitialOffset(),\r\n    })\r\n  );\r\n\r\n  if (isDragging) {\r\n    // console.log(\"isDragging\");\r\n  }\r\n\r\n  function getItemStyles(\r\n    initialOffset: XYCoord | null,\r\n    currentOffset: XYCoord | null\r\n  ) {\r\n    if (!initialOffset || !currentOffset) {\r\n      return {\r\n        display: \"none\",\r\n      };\r\n    }\r\n\r\n    let { x, y } = currentOffset;\r\n\r\n    const transform = `translate(${x}px, ${y}px)`;\r\n    return {\r\n      transform,\r\n      WebkitTransform: transform,\r\n    };\r\n  }\r\n\r\n  const fieildElem = document.getElementById(\"field\");\r\n\r\n  function renderItem() {\r\n    switch (itemType) {\r\n      case ItemDragTypes.PLAYER:\r\n        const styledPreview = (\r\n          <StyledPreviewWrap>\r\n            <div style={getItemStyles(initialOffset, currentOffset)}>\r\n              {/* <div style={{ ...styles }}></div> */}\r\n              <StyledCommonPlayerCard image={image} isCurrent={isCurrent} />\r\n            </div>\r\n          </StyledPreviewWrap>\r\n        );\r\n        switch (fieildElem) {\r\n          case null: {\r\n            return styledPreview;\r\n          }\r\n          default: {\r\n            const portal = ReactDOM.createPortal(\r\n              <PLayersPortal coordX={coordX} coordY={coordY}>\r\n                {styledPreview}\r\n              </PLayersPortal>,\r\n              fieildElem\r\n            );\r\n            return portal;\r\n          }\r\n        }\r\n\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n\r\n  if (!isDragging || !isCurrent) {\r\n    if (isCurrent) {\r\n    }\r\n\r\n    return null;\r\n  } else {\r\n    return renderItem();\r\n  }\r\n\r\n  // <StyledPreviewWrap>\r\n  //   <div style={getItemStyles(initialOffset, currentOffset)}>\r\n  //     {renderItem()}\r\n  //   </div>\r\n  // </StyledPreviewWrap>\r\n};\r\n","import { FC, useEffect, useMemo } from \"react\";\r\nimport { useSelector } from \"react-redux\";\r\n\r\nimport styled from \"styled-components\";\r\nimport { useDrag } from \"react-dnd\";\r\n\r\nimport { ItemDragTypes } from \"../../shared/ItemTypes\";\r\nimport { State } from \"../../business/types\";\r\nimport { PreviewDrag } from \"../common/DragPreview/PreviewDrag\";\r\nimport { StyledCommonPlayerCard } from \"../common/DragPreview/StyledCommonPlayerCard\";\r\nimport { getEmptyImage } from \"react-dnd-html5-backend\";\r\n\r\nconst StyledPlayerCard = styled(StyledCommonPlayerCard)<\r\n  Omit<PlayerItemProps, \"coordX\" | \"coordY\">\r\n>`\r\n  z-index: ${(props) => {\r\n    if (props.isCurrent) {\r\n      return \"10\";\r\n    } else {\r\n      return \"3\";\r\n    }\r\n  }};\r\n\r\n  &:after {\r\n    content: \"\";\r\n    position: absolute;\r\n    width: 36px;\r\n    height: 36px;\r\n    border-radius: 1px;\r\n    padding: 4px;\r\n    left: 0px;\r\n    top: 0px;\r\n\r\n    border: ${(props) => {\r\n      if (props.needHighlightning) {\r\n        return \"3px solid rgb(55 163 0 / 52%);\";\r\n      }\r\n    }};\r\n  }\r\n`;\r\n\r\ntype PlayerStyleProps = {\r\n  isCurrent: boolean;\r\n  needHighlightning?: boolean;\r\n  image: string;\r\n  coordX: string;\r\n  coordY: string;\r\n};\r\n\r\ntype PlayerItemProps = {\r\n  id: string;\r\n  onClick: any;\r\n} & PlayerStyleProps;\r\n\r\nexport const PlayerCard: FC<PlayerItemProps> = ({\r\n  id,\r\n  isCurrent,\r\n  needHighlightning,\r\n  image,\r\n  onClick,\r\n  coordX,\r\n  coordY,\r\n}) => {\r\n  const [gameStateType] = useSelector((state: State) => [state.gameState.type]);\r\n\r\n  const playerCardCanBeDragged =\r\n    gameStateType === \"gameStarted.playerMove\" && isCurrent;\r\n\r\n  const [{ isDragging }, drag, dragPreview] = useDrag(\r\n    () => ({\r\n      item: { id: id },\r\n      type: ItemDragTypes.PLAYER,\r\n      collect: (monitor) => ({ isDragging: !!monitor.isDragging() }),\r\n      canDrag: (monitor) => {\r\n        return playerCardCanBeDragged;\r\n      },\r\n    }),\r\n    [id, gameStateType]\r\n  );\r\n\r\n  //Hide initial preview on dragging\r\n  useEffect(() => {\r\n    if (dragPreview) {\r\n      dragPreview(getEmptyImage(), { captureDraggingState: true });\r\n    }\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, []);\r\n\r\n  const memoCard = useMemo(() => {\r\n    <>\r\n      <StyledPlayerCard\r\n        style={{\r\n          opacity: isDragging ? 0 : 1,\r\n        }}\r\n        ref={drag}\r\n        id={id}\r\n        isCurrent={isCurrent}\r\n        needHighlightning={needHighlightning}\r\n        image={image}\r\n        onClick={onClick}\r\n      />\r\n      <PreviewDrag\r\n        isCurrent={isCurrent}\r\n        image={image}\r\n        coordX={coordX}\r\n        coordY={coordY}\r\n      />\r\n    </>;\r\n  }, []);\r\n\r\n  return (\r\n    <>\r\n      <StyledPlayerCard\r\n        style={{\r\n          opacity: isDragging ? 0 : 1,\r\n        }}\r\n        ref={drag}\r\n        id={id}\r\n        isCurrent={isCurrent}\r\n        needHighlightning={needHighlightning}\r\n        image={image}\r\n        onClick={onClick}\r\n      />\r\n      <PreviewDrag\r\n        isCurrent={isCurrent}\r\n        image={image}\r\n        coordX={coordX}\r\n        coordY={coordY}\r\n      />\r\n    </>\r\n  );\r\n};\r\n","import ReactDOM from \"react-dom\";\r\nimport React, { useCallback } from \"react\";\r\n\r\nimport { useDispatch, useSelector } from \"react-redux\";\r\nimport styled from \"styled-components\";\r\n\r\nimport {\r\n  TypeOfInventoryCard,\r\n  PlayerListType,\r\n  PLayerType,\r\n  State,\r\n} from \"../../business/types\";\r\n\r\n//TODO:organize images!\r\nimport player from \"./player.png\";\r\nimport player2 from \"./player2.png\";\r\nimport player3 from \"./player3.png\";\r\nimport player4 from \"./player4.png\";\r\nimport { PlayerCard } from \"./PlayerCard\";\r\n\r\ntype PlayerCardListType = {\r\n  needSplitCards?: boolean;\r\n  needReverseCards?: boolean;\r\n};\r\n\r\ntype PlayerListItem = {\r\n  playerListOnCell: PLayerType[];\r\n  playerList: PlayerListType;\r\n  numberOfPlayer: number;\r\n};\r\n\r\ntype PortalType = {\r\n  coordX: string;\r\n  coordY: string;\r\n  isCurrPlayer?: boolean;\r\n};\r\n\r\nconst PLayersPortal = styled.div<PortalType>`\r\n  position: relative;\r\n  display: flex;\r\n  left: ${(props) => {\r\n    return `${Number(props.coordX) * 50}px`;\r\n  }};\r\n\r\n  bottom: ${(props) => {\r\n    return `${Number(props.coordY) * 50 + 50}px`;\r\n  }};\r\n\r\n  pointer-events: ${({ isCurrPlayer }) => {\r\n    return isCurrPlayer ? \"initial\" : \"none\";\r\n  }};\r\n`;\r\n\r\nconst ContextMenuPortal = styled.div<PortalType>`\r\n  position: relative;\r\n  display: flex;\r\n  left: ${(props) => {\r\n    return `${Number(props.coordX) * 50 - 100}px`;\r\n  }};\r\n\r\n  bottom: ${(props) => {\r\n    return `${Number(props.coordY) * 50}px`;\r\n  }};\r\n`;\r\n\r\nconst PlayerCardList = styled.div<PlayerCardListType>`\r\n  display: flex;\r\n  flex-wrap: nowrap;\r\n  position: absolute;\r\n  font-size: 12px;\r\n  font-weight: bold;\r\n\r\n  flex-direction: ${(props) => {\r\n    if (props.needReverseCards) {\r\n      return \"row-reverse\";\r\n    } else {\r\n      return \"row\";\r\n    }\r\n  }};\r\n\r\n  /*  turned off -return \"relative !important\"- for customDragPreview\r\n*/\r\n  > * {\r\n    position: ${(props) => {\r\n      if (props.needSplitCards) {\r\n        return \"relative \";\r\n      }\r\n    }};\r\n\r\n    margin: ${(props) => {\r\n      if (props.needSplitCards) {\r\n        return \"0 -12px\";\r\n      }\r\n    }};\r\n  }\r\n`;\r\n\r\ntype ContextMenuType = {\r\n  coord?: { x?: number; y?: number };\r\n};\r\n\r\nconst ContextMenu = styled.div<ContextMenuType>`\r\n  display: block;\r\n  flex-direction: column;\r\n  position: absolute;\r\n  width: 100px;\r\n  height: 100px;\r\n  background-color: #ffffff;\r\n  box-shadow: 0 0 10px rgb(0 0 0 / 50%);\r\n  justify-content: start;\r\n  padding: 21px 0 0 12px;\r\n  box-sizing: border-box;\r\n  left: ${(props) => {\r\n    if (props.coord?.x) {\r\n      return `${props.coord?.x}px`;\r\n    } else {\r\n      return \"0px\";\r\n    }\r\n  }};\r\n  top: ${(props) => {\r\n    return `${props.coord?.y}px`;\r\n  }};\r\n`;\r\n\r\nconst Button = styled.button`\r\n  height: 30px;\r\n  width: 70px;\r\n`;\r\n\r\nexport const Player = (props: PlayerListItem) => {\r\n  const dispatch = useDispatch();\r\n\r\n  const gameState = useSelector((state: State) => state.gameState);\r\n\r\n  const playerImageList = [player, player2, player3, player4];\r\n\r\n  const { playerListOnCell, playerList, numberOfPlayer } = props;\r\n\r\n  const needSplitCards = playerListOnCell.length > 1;\r\n\r\n  /**\r\n   * If first the index of active card - then it be rendered first.\r\n   */\r\n  const indexOfActiveCard = playerListOnCell.findIndex((playerCard) => {\r\n    return playerCard.orderNumber === numberOfPlayer;\r\n  });\r\n\r\n  const needReverseCards = indexOfActiveCard !== 0 && needSplitCards;\r\n\r\n  const MemoizedClickHandler = (playerCardItem: any) =>\r\n    dispatch({\r\n      type: \"clickedPlayer\",\r\n      payload: playerCardItem,\r\n    });\r\n\r\n  //err when click enemy on player\r\n  // const MemoizedClickHandler = (playerCardItem: any) =>\r\n  //   useCallback(\r\n  //     () =>\r\n  //       dispatch({\r\n  //         type: \"clickedPlayer\",\r\n  //         payload: playerCardItem,\r\n  //       }),\r\n  //     [playerCardItem]\r\n  //   );\r\n  /*     useCallback(\r\n      () =>\r\n        dispatch({\r\n          type: \"clickedPlayer\",\r\n          payload: playerCardItem,\r\n        }),\r\n      []\r\n    ); */\r\n\r\n  const playerCardList = (\r\n    <PlayerCardList\r\n      needSplitCards={needSplitCards}\r\n      needReverseCards={needReverseCards}\r\n    >\r\n      {playerListOnCell.map((playerCardItem, index) => {\r\n        const coordOfAvailableCards = gameState.coordOfAvailableCards;\r\n        const isActivePlayerAlive = playerList[numberOfPlayer] ? true : false;\r\n\r\n        const coordString = playerListOnCell[0].coord;\r\n        const [hor, vert] = coordString.split(\".\");\r\n        switch (isActivePlayerAlive) {\r\n          case false: {\r\n            return (\r\n              <PlayerCard\r\n                id={`player${playerCardItem.orderNumber}`}\r\n                key={index}\r\n                image={playerImageList[playerCardItem.orderNumber]}\r\n                isCurrent={numberOfPlayer === playerCardItem.orderNumber}\r\n                needHighlightning={false}\r\n                onClick={() => MemoizedClickHandler(playerCardItem)}\r\n                coordX={String(hor)}\r\n                coordY={String(vert)}\r\n              ></PlayerCard>\r\n            );\r\n          }\r\n          case true: {\r\n            const activePlayerCoord = playerList[numberOfPlayer].coord;\r\n            const currPlayer = playerList[numberOfPlayer];\r\n            const typeOfChosedCard = currPlayer.inventory.cardSelected;\r\n\r\n            const playerCard = (\r\n              <PlayerCard\r\n                id={`player${playerCardItem.orderNumber}`}\r\n                key={index}\r\n                image={playerImageList[playerCardItem.orderNumber]}\r\n                isCurrent={numberOfPlayer === playerCardItem.orderNumber}\r\n                needHighlightning={calculateHighlightning(\r\n                  coordOfAvailableCards,\r\n                  typeOfChosedCard,\r\n                  playerCardItem,\r\n                  activePlayerCoord\r\n                )}\r\n                coordX={String(hor)}\r\n                coordY={String(vert)}\r\n                onClick={() =>\r\n                  dispatch({\r\n                    type: \"clickedPlayer\",\r\n                    payload: playerCardItem,\r\n                  })\r\n                }\r\n              ></PlayerCard>\r\n            );\r\n\r\n            const contextMenu = (\r\n              <ContextMenu\r\n                key=\"contextMenu\"\r\n                id={\"contextMenu\"}\r\n                className={\"contextMenu\"}\r\n              >\r\n                <Button\r\n                  onClick={() => {\r\n                    dispatch({\r\n                      type: \"clickedContextMenu\",\r\n                      payload: {\r\n                        card: playerCardItem,\r\n                        buttonType: \"share\",\r\n                      },\r\n                    });\r\n                  }}\r\n                >\r\n                  передать\r\n                </Button>\r\n                <Button\r\n                  onClick={() => {\r\n                    dispatch({\r\n                      type: \"clickedContextMenu\",\r\n                      payload: { card: playerCardItem, buttonType: \"heal\" },\r\n                    });\r\n                  }}\r\n                >\r\n                  лечить\r\n                </Button>\r\n              </ContextMenu>\r\n            );\r\n\r\n            switch (playerCardItem.showContextMenu) {\r\n              case true: {\r\n                const activePLayerCoord = playerList[numberOfPlayer].coord;\r\n                const currPlayerCoord = playerCardItem.coord;\r\n\r\n                const contextMenuCoord = getContextMenuCoord(\r\n                  activePLayerCoord,\r\n                  currPlayerCoord\r\n                );\r\n\r\n                const [hor, vert] = contextMenuCoord.split(\".\");\r\n                const fieildElem = document.getElementById(\"field\");\r\n\r\n                switch (fieildElem) {\r\n                  case null: {\r\n                    return playerCard;\r\n                  }\r\n\r\n                  default: {\r\n                    const portal = ReactDOM.createPortal(\r\n                      <ContextMenuPortal\r\n                        coordX={String(hor)}\r\n                        coordY={String(vert)}\r\n                        key=\"portal\"\r\n                      >\r\n                        {contextMenu}\r\n                      </ContextMenuPortal>,\r\n                      fieildElem\r\n                    );\r\n                    return (\r\n                      <React.Fragment key=\"fragment\">\r\n                        {playerCard}\r\n                        {portal}\r\n                      </React.Fragment>\r\n                    );\r\n                  }\r\n                }\r\n              }\r\n              default: {\r\n                return playerCard;\r\n              }\r\n            }\r\n          }\r\n          default: {\r\n            return null;\r\n          }\r\n        }\r\n      })}\r\n    </PlayerCardList>\r\n  );\r\n\r\n  const fieildElem = document.getElementById(\"field\");\r\n\r\n  switch (fieildElem) {\r\n    case null: {\r\n      return playerCardList;\r\n    }\r\n\r\n    default: {\r\n      //TODO: coordinate handling!\r\n\r\n      const coordString = playerListOnCell[0].coord;\r\n      const [hor, vert] = coordString.split(\".\");\r\n\r\n      const isCurrPlayer =\r\n        playerList[numberOfPlayer] &&\r\n        playerList[numberOfPlayer].coord === coordString;\r\n\r\n      const portal = ReactDOM.createPortal(\r\n        <PLayersPortal coordX={hor} coordY={vert} isCurrPlayer={isCurrPlayer}>\r\n          {playerCardList}\r\n        </PLayersPortal>,\r\n        fieildElem\r\n      );\r\n\r\n      switch (needSplitCards) {\r\n        case false: {\r\n          return playerCardList;\r\n          // switch (isPlayerAlone) {\r\n          //   case true: {\r\n          //     return portal;\r\n          //   }\r\n\r\n          //   case false: {\r\n          //     return playerCardList;\r\n          //   }\r\n\r\n          //   default: {\r\n          //     return playerCardList;\r\n          //   }\r\n          // }\r\n        }\r\n\r\n        case true: {\r\n          return portal;\r\n        }\r\n\r\n        default: {\r\n          return playerCardList;\r\n        }\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nconst calculateHighlightning = (\r\n  coordOfAvailableCards: string[] | null,\r\n  typeOfChosedCard: TypeOfInventoryCard,\r\n  playerCardItem: PLayerType,\r\n  activePlayerCoord: string\r\n) => {\r\n  const isActivePlayer = activePlayerCoord === playerCardItem.coord;\r\n  switch (coordOfAvailableCards) {\r\n    case null: {\r\n      return false;\r\n    }\r\n    default: {\r\n      const canInteractWithPlayer = coordOfAvailableCards.includes(\r\n        playerCardItem.coord\r\n      );\r\n\r\n      switch (canInteractWithPlayer) {\r\n        case true: {\r\n          switch (typeOfChosedCard) {\r\n            case \"health\": {\r\n              return true;\r\n            }\r\n\r\n            case \"weapon\":\r\n            case \"boards\": {\r\n              switch (!isActivePlayer) {\r\n                case true: {\r\n                  return true;\r\n                }\r\n                case false: {\r\n                  return false;\r\n                }\r\n                default: {\r\n                  return false;\r\n                }\r\n              }\r\n            }\r\n\r\n            default: {\r\n              return false;\r\n            }\r\n          }\r\n        }\r\n        case false: {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nconst getContextMenuCoord = (\r\n  activePLayerCoord: string,\r\n  currPlayerCoord: string\r\n) => {\r\n  const [horActive, vertActive] = activePLayerCoord.split(\".\");\r\n  const [horCurrent, vertCurrent] = currPlayerCoord.split(\".\");\r\n\r\n  const differenceHor = getNewCoordHor(horCurrent, horActive);\r\n  const differenceVert = getNewCoordVert(vertCurrent, vertActive);\r\n  return `${differenceHor}.${differenceVert}`;\r\n};\r\n\r\nconst getNewCoordHor = (firstNumber: string, secondNUmber: string) => {\r\n  const difference = Number(firstNumber) - Number(secondNUmber);\r\n  if (difference > 0) {\r\n    return Number(secondNUmber);\r\n  } else if (difference < 0) {\r\n    return Number(secondNUmber) + 3;\r\n  } else {\r\n    return Number(secondNUmber);\r\n  }\r\n};\r\n\r\nconst getNewCoordVert = (firstNumber: string, secondNUmber: string) => {\r\n  const difference = Number(firstNumber) - Number(secondNUmber);\r\n  if (difference > 0) {\r\n    return Number(secondNUmber) + 2;\r\n  } else if (difference < 0) {\r\n    return Number(secondNUmber) + 1;\r\n  } else {\r\n    return Number(secondNUmber) + 1;\r\n  }\r\n};\r\n","export default __webpack_public_path__ + \"static/media/boards.3824da3f.png\";","import { FC } from \"react\";\r\nimport styled from \"styled-components\";\r\nimport { CardAppearance } from \"../../business/types\";\r\nimport { StyledCommonCard } from \"../common/CommonCard\";\r\n\r\nimport img from \"./boards.png\";\r\nimport brainImg from \"../common/CommonCard/brain_4.png\";\r\n\r\ntype BoardsApperanceType = {\r\n  apperance: \"closed\" | \"open\";\r\n  ref: any;\r\n};\r\n\r\nconst CardContainer = styled.div`\r\n  width: 50px;\r\n  height: 50px;\r\n  position: relative;\r\n  transform-style: preserve-3d;\r\n`;\r\n\r\nconst CardFace = styled.div`\r\n  position: absolute;\r\n  height: 100%;\r\n  width: 100%;\r\n  backface-visibility: hidden;\r\n`;\r\n\r\nconst CardFront = styled(CardFace)`\r\n  ${StyledCommonCard}\r\n  background-color: unset;\r\n  background-image: url(${img});\r\n  border-color: gray;\r\n`;\r\n\r\nconst CardBack = styled(CardFace)<{ apperance: \"closed\" | \"open\" }>`\r\n  ${StyledCommonCard}\r\n  background-image: url(${brainImg});\r\n  display: ${({ apperance }) => {\r\n    if (apperance === \"open\") {\r\n      return \"none\";\r\n    }\r\n  }};\r\n`;\r\n\r\nexport const BoardsCard: FC<{\r\n  apperance: CardAppearance;\r\n  refList: {\r\n    cardContainerRef: React.RefObject<HTMLDivElement>;\r\n    cardFrontRef: React.RefObject<HTMLDivElement>;\r\n  };\r\n}> = ({ apperance, refList }) => {\r\n  return (\r\n    <CardContainer ref={refList.cardContainerRef}>\r\n      <CardFront ref={refList.cardFrontRef} />\r\n      <CardBack apperance={apperance} />\r\n    </CardContainer>\r\n  );\r\n};\r\n","export default __webpack_public_path__ + \"static/media/weapon.b3c5e028.png\";","import styled from \"styled-components\";\r\nimport { StyledCommonCard } from \"../common/CommonCard\";\r\nimport { CardAppearance } from \"../../business/types\";\r\nimport img from \"./weapon.png\";\r\nimport brainImg from \"../common/CommonCard/brain_4.png\";\r\nimport { FC } from \"react\";\r\n\r\ntype WeaponApperanceType = {\r\n  apperance?: \"closed\" | \"open\";\r\n  ref: any;\r\n};\r\n\r\nconst CardContainer = styled.div<WeaponApperanceType>`\r\n  width: 50px;\r\n  height: 50px;\r\n  position: relative;\r\n  transform-style: preserve-3d;\r\n`;\r\n\r\nconst CardFace = styled.div`\r\n  position: absolute;\r\n  height: 100%;\r\n  width: 100%;\r\n  backface-visibility: hidden;\r\n`;\r\n\r\nconst CardFront = styled(CardFace)`\r\n  ${StyledCommonCard}\r\n  background-color: unset;\r\n  background-image: url(${img});\r\n  border-color: gray;\r\n`;\r\n\r\nconst CardBack = styled(CardFace)<{ apperance: \"closed\" | \"open\" }>`\r\n  ${StyledCommonCard}\r\n  background-image: url(${brainImg});\r\n  display: ${({ apperance }) => {\r\n    if (apperance === \"open\") {\r\n      return \"none\";\r\n    }\r\n  }};\r\n`;\r\n\r\nexport const WeaponCard: FC<{\r\n  apperance: CardAppearance;\r\n  refList: {\r\n    cardContainerRef: React.RefObject<HTMLDivElement>;\r\n    cardFrontRef: React.RefObject<HTMLDivElement>;\r\n  };\r\n}> = ({ apperance, refList }) => {\r\n  return (\r\n    <CardContainer ref={refList.cardContainerRef}>\r\n      <CardFront ref={refList.cardFrontRef} />\r\n      <CardBack apperance={apperance} />\r\n    </CardContainer>\r\n  );\r\n};\r\n","export default __webpack_public_path__ + \"static/media/zombie.0f20e592.png\";","import { FC, useEffect } from \"react\";\r\nimport styled from \"styled-components\";\r\nimport { useDrag } from \"react-dnd\";\r\n\r\nimport { ItemDragTypes } from \"../../shared/ItemTypes\";\r\nimport { StyledCommonCard } from \"../common/CommonCard\";\r\nimport { CardAppearance, EnemyCardType, State } from \"../../business/types\";\r\n\r\nimport zombie from \"./zombie.png\";\r\n// import zombie_defeated from \"./zombie_defeated.png\";\r\n\r\nimport brainImg from \"../common/CommonCard/brain_4.png\";\r\nimport { useDispatch, useSelector } from \"react-redux\";\r\nimport { getEmptyImage } from \"react-dnd-html5-backend\";\r\nimport { PreviewDrag } from \"../common/DragPreview/PreviewDrag\";\r\nimport { StyledCommonPlayerCard } from \"../common/DragPreview/StyledCommonPlayerCard\";\r\n\r\ntype WeaponApperanceType = {\r\n  apperance?: \"closed\" | \"open\";\r\n  ref: any;\r\n};\r\n\r\nconst CardContainer = styled.div<WeaponApperanceType>`\r\n  width: 50px;\r\n  height: 50px;\r\n  position: relative;\r\n  transform-style: preserve-3d;\r\n`;\r\n\r\nconst CardFace = styled.div`\r\n  position: absolute;\r\n  height: 100%;\r\n  width: 100%;\r\n  backface-visibility: hidden;\r\n`;\r\n\r\nconst CardFront = styled(CardFace)<{ isCurrent: boolean }>`\r\n  ${StyledCommonCard}\r\n  background-color: unset;\r\n  background-image: url(${zombie});\r\n  border-color: gray;\r\n  &:before {\r\n    content: \"\";\r\n    position: absolute;\r\n    width: 24px;\r\n    height: 24px;\r\n    border-radius: 1px;\r\n\r\n    border: ${(props) => {\r\n      if (props.isCurrent) {\r\n        return \"5px solid #8834b8\";\r\n      }\r\n    }};\r\n\r\n    pointer-events: none;\r\n    opacity: 0.5;\r\n    padding: 4px;\r\n    left: 4px;\r\n    top: 4px;\r\n  }\r\n`;\r\n\r\nconst CardBack = styled(CardFace)<{ apperance: \"closed\" | \"open\" }>`\r\n  ${StyledCommonCard}\r\n  background-image: url(${brainImg});\r\n  display: ${({ apperance }) => {\r\n    if (apperance === \"open\") {\r\n      return \"none\";\r\n    }\r\n  }};\r\n`;\r\n\r\nexport const EnemyView: FC<{\r\n  id: string;\r\n  apperance: CardAppearance;\r\n  enemyCard: EnemyCardType;\r\n  isCurrent: boolean;\r\n  refList: {\r\n    cardContainerRef: React.RefObject<HTMLDivElement>;\r\n    cardFrontRef: React.RefObject<HTMLDivElement>;\r\n  };\r\n}> = ({ id, apperance, refList, enemyCard, isCurrent }) => {\r\n  const dispatch = useDispatch();\r\n\r\n  const [gameStateType] = useSelector((state: State) => [state.gameState.type]);\r\n\r\n  const [hor, vert] = enemyCard.coord.split(\".\");\r\n\r\n  const enemyCardCanBeDragged = gameStateType === \"enemyMove\" && isCurrent;\r\n  /*   console.log(\"enemyCardCanBeDragged\", enemyCardCanBeDragged); */\r\n\r\n  const [{ isDragging }, drag, dragPreview] = useDrag(\r\n    () => ({\r\n      item: { id: id },\r\n      type: ItemDragTypes.PLAYER,\r\n      collect: (monitor) => ({ isDragging: !!monitor.isDragging() }),\r\n      canDrag: (monitor) => {\r\n        return enemyCardCanBeDragged;\r\n      },\r\n    }),\r\n    [id, gameStateType]\r\n  );\r\n\r\n  //Hide initial preview on dragging\r\n  useEffect(() => {\r\n    if (dragPreview) {\r\n      dragPreview(getEmptyImage(), { captureDraggingState: true });\r\n    }\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, []);\r\n\r\n  /**\r\n   * CardContainer ref-нужен для передачи ссылки на карточку и для навешивания драг\r\n   */\r\n  return (\r\n    <>\r\n      <CardContainer\r\n        style={{\r\n          opacity: isDragging ? 0 : 1,\r\n        }}\r\n        ref={apperance === \"closed\" ? refList.cardContainerRef : drag}\r\n        onClick={() => {\r\n          dispatch({\r\n            type: \"clickedEnemy\",\r\n            payload: { enemyCard: enemyCard },\r\n          });\r\n        }}\r\n      >\r\n        <CardFront ref={refList.cardFrontRef} isCurrent={isCurrent} />\r\n        <CardBack apperance={apperance} />\r\n      </CardContainer>\r\n      <PreviewDrag\r\n        isCurrent={isCurrent}\r\n        image={zombie}\r\n        coordX={hor}\r\n        coordY={vert}\r\n      />\r\n    </>\r\n  );\r\n};\r\n","import { FC } from \"react\";\r\nimport { useDispatch } from \"react-redux\";\r\nimport styled from \"styled-components\";\r\n\r\nimport { CardAppearance, EnemyCardType } from \"../../business/types\";\r\n\r\nimport { EnemyView } from \"./EnemyView\";\r\n\r\ntype EnemyCardContainerType = {\r\n  needSplitCards?: boolean;\r\n  needReverseCards?: boolean;\r\n};\r\n\r\nexport const EnemyCard: FC<{\r\n  isCurrent: boolean;\r\n  needSplitCards: boolean;\r\n  needReverseCards: boolean;\r\n  apperance: CardAppearance;\r\n  enemyCard: EnemyCardType;\r\n  order: string;\r\n  refList: {\r\n    cardContainerRef: React.RefObject<HTMLDivElement>;\r\n    cardFrontRef: React.RefObject<HTMLDivElement>;\r\n  };\r\n}> = ({\r\n  needSplitCards,\r\n  needReverseCards,\r\n  apperance,\r\n  refList,\r\n  enemyCard,\r\n  isCurrent,\r\n  order,\r\n}) => {\r\n  return (\r\n    <EnemyView\r\n      // key={`deadPlayer${order}`}\r\n      id={`deadPlayer${order}`}\r\n      isCurrent={isCurrent}\r\n      apperance={apperance}\r\n      refList={refList}\r\n      enemyCard={enemyCard}\r\n    />\r\n  );\r\n};\r\n","import React, { useMemo } from \"react\";\r\nimport styled from \"styled-components\";\r\nimport { useDispatch, useSelector } from \"react-redux\";\r\n\r\nimport {\r\n  CardAppearance,\r\n  CellType,\r\n  DeadPlayerListType,\r\n  EnemyListType,\r\n  State,\r\n  TypeOfCard,\r\n} from \"../../business/types\";\r\nimport { useOpenCardAnimation } from \"../../business/effects/useOpenCardAnimation\";\r\n\r\nimport { HealthCard, BoardsCard, WeaponCard } from \"../../components\";\r\nimport { EnemyCard } from \"../../components/Enemy/EnemyCard\";\r\n\r\n//TODO: при 1 секунде- промаргивание\r\nconst ANIMATION_TIME = 3;\r\n\r\ntype CardsListType = \"all\" | \"enemy\" | \"inventory\";\r\n\r\ntype EnemyCardContainerType = {\r\n  needSplitCards?: boolean;\r\n  needReverseCards?: boolean;\r\n};\r\n\r\nconst CardList = styled.div<{ needSplitCards: boolean }>`\r\n  display: flex;\r\n  width: 50px;\r\n  height: 50px;\r\n  flex-wrap: nowrap;\r\n  position: absolute;\r\n\r\n  > * {\r\n    position: ${(props) => {\r\n      if (props.needSplitCards) {\r\n        return \"relative \";\r\n      }\r\n    }};\r\n\r\n    margin: ${(props) => {\r\n      if (props.needSplitCards) {\r\n        return \"0 -12px\";\r\n      }\r\n    }};\r\n\r\n    flex-direction: ${(props) => {\r\n      if (props.needSplitCards) {\r\n        return \"row-reverse\";\r\n      } else {\r\n        return \"row\";\r\n      }\r\n    }};\r\n  }\r\n`;\r\n\r\n// const EnemyCardContainer = styled.div<EnemyCardContainerType>`\r\n//   display: flex;\r\n//   flex-wrap: nowrap;\r\n//   position: absolute;\r\n//   font-size: 12px;\r\n//   font-weight: bold;\r\n//   flex-direction: ${(props) => {\r\n//     if (props.needReverseCards) {\r\n//       return \"row-reverse\";\r\n//     } else {\r\n//       return \"row\";\r\n//     }\r\n//   }};\r\n\r\n//   margin: ${(props) => {\r\n//     if (props.needSplitCards) {\r\n//       return \" 0 0 !important;\";\r\n//     }\r\n//   }};\r\n\r\n//   > * {\r\n//     position: ${(props) => {\r\n//       if (props.needSplitCards) {\r\n//         return \"relative !important\";\r\n//       }\r\n//     }};\r\n\r\n//     margin: ${(props) => {\r\n//       if (props.needSplitCards) {\r\n//         return \"0 -12px\";\r\n//       }\r\n//     }};\r\n//   }\r\n// `;\r\n\r\n/**\r\n * Return inventory and other closed cards\r\n */\r\nconst Card = React.memo(function _CardView({\r\n  apperance,\r\n  refList,\r\n  type,\r\n}: {\r\n  type: TypeOfCard;\r\n  coord: string;\r\n  apperance: CardAppearance;\r\n  refList: {\r\n    cardContainerRef: React.RefObject<HTMLDivElement>;\r\n    cardFrontRef: React.RefObject<HTMLDivElement>;\r\n  };\r\n}) {\r\n  switch (type) {\r\n    case \"boards\": {\r\n      return <BoardsCard apperance={apperance} refList={refList} />;\r\n    }\r\n    case \"weapon\": {\r\n      return <WeaponCard apperance={apperance} refList={refList} />;\r\n    }\r\n    case \"health\": {\r\n      return <HealthCard apperance={apperance} refList={refList} />;\r\n    }\r\n\r\n    default: {\r\n      return null;\r\n    }\r\n  }\r\n});\r\n\r\n/**\r\n * Represent some card on one Cell: inventory and enemy, for now all except player\r\n */\r\nexport const CardListEl = React.memo(function _CardListEl({\r\n  type,\r\n  cell,\r\n  currCoord,\r\n  enemyList,\r\n  deadPlayerList,\r\n}: /*   refList, */\r\n{\r\n  cell: CellType;\r\n  type: CardsListType;\r\n  currCoord: string;\r\n  enemyList: EnemyListType;\r\n  deadPlayerList: DeadPlayerListType;\r\n  /* \r\n  refList: {\r\n    cardContainerRef: React.RefObject<HTMLDivElement>;\r\n    cardFrontRef: React.RefObject<HTMLDivElement>;\r\n  }; */\r\n}) {\r\n  const dispatch = useDispatch();\r\n  const [hor, vert] = currCoord.split(\".\");\r\n\r\n  const activePlayerNumber = useSelector(\r\n    (state: State) => state.activePlayerNumber\r\n  );\r\n\r\n  const playerList = useSelector((state: State) => {\r\n    const hasPlayerOnCell =\r\n      state.playerList[state.activePlayerNumber]?.coord === currCoord;\r\n    return hasPlayerOnCell ? state.playerList : null;\r\n  });\r\n\r\n  const currEnemyIndex = useSelector((state: State) => {\r\n    const enemyOrderNumber = state.deadPlayerList\r\n      ? state.deadPlayerList[state.activePlayerNumber]?.index\r\n      : undefined;\r\n    return enemyOrderNumber;\r\n  });\r\n\r\n  const hasInventoryCards = useSelector((state: State) => {\r\n    const hasInventory = state.gameField.values[currCoord].cardItem?.length;\r\n\r\n    return hasInventory;\r\n  });\r\n\r\n  //TODO: почему только открытые карточки???\r\n  const enemyListOnCell = Object.entries(enemyList).filter(\r\n    ([string, enemyCard]) => {\r\n      return enemyCard.coord === currCoord;\r\n    }\r\n  );\r\n\r\n  const enemyCardsOnCell = enemyListOnCell.map(([string, enemyCard]) => {\r\n    return enemyCard;\r\n  });\r\n\r\n  //TODO: по идее в doEffect можно закидывать номер ячейки, на которой открытие карточки\r\n  const needRenderOpenCard = useSelector((state: State) => {\r\n    const playerCoord = state.playerList[state.activePlayerNumber]?.coord;\r\n    if (playerCoord === currCoord) {\r\n      const hasEnemyCard =\r\n        playerCoord &&\r\n        Object.values(state.enemyList).find(\r\n          (enemyItem) => enemyItem.coord === playerCoord\r\n        );\r\n\r\n      const hasInventoryCards =\r\n        state.gameField.values[playerCoord].cardItem?.length;\r\n\r\n      const needRenderOpenCard = Boolean(hasEnemyCard || hasInventoryCards);\r\n      return needRenderOpenCard;\r\n    } else {\r\n      return false;\r\n    }\r\n  });\r\n\r\n  const getNextPhase = () => {\r\n    //for inventory and for other card ???\r\n    // console.log(\"taking Card\");\r\n    dispatch({ type: \"req-openCard\" });\r\n  };\r\n\r\n  const { cardRef } = useOpenCardAnimation({\r\n    needRun: needRenderOpenCard,\r\n    maxTime: ANIMATION_TIME,\r\n    onTimerEnd: getNextPhase,\r\n  });\r\n\r\n  const MemoCard = useMemo(() => Card, []);\r\n\r\n  const cardItemList = cell.cardItem;\r\n\r\n  /**\r\n   * Пока рассматривается возможность нахождения только одной карточки инвентаря на ячейке\r\n   */\r\n  const inventoryElem = cardItemList?.length ? (\r\n    <>\r\n      {cardItemList.map((cardItem) => {\r\n        return type === \"all\" || type === \"inventory\" ? (\r\n          <MemoCard\r\n            refList={cardRef}\r\n            key={`${hor}.${vert}.health`}\r\n            apperance={cardItem.appearance}\r\n            type={cardItem.name}\r\n            coord={currCoord}\r\n          />\r\n        ) : null;\r\n      })}\r\n    </>\r\n  ) : null;\r\n\r\n  const needSplitCards = enemyCardsOnCell.length > 1;\r\n  // console.log(\"needSplitCards\", needSplitCards);\r\n\r\n  if (enemyCardsOnCell.length) {\r\n    // console.log(\"enemyListOnCell\", enemyListOnCell);\r\n    // console.log(\"enemyCardsOnCell\", currCoord, enemyCardsOnCell);\r\n  }\r\n\r\n  const firstItemIsClosed =\r\n    enemyListOnCell.length && enemyListOnCell[0][1].appearance === \"closed\";\r\n\r\n  const isActiveEnemyCard =\r\n    deadPlayerList && deadPlayerList?.[activePlayerNumber]?.index ? true : null;\r\n\r\n  //find out index of active dead player\r\n  const indexOfActiveCard = enemyListOnCell.findIndex(([index, enemyCard]) => {\r\n    if (deadPlayerList && deadPlayerList[activePlayerNumber]) {\r\n      return Number(index) === Number(deadPlayerList[activePlayerNumber].index);\r\n    } else {\r\n      return -1;\r\n    }\r\n  });\r\n\r\n  const needReverseCards = Boolean(\r\n    (indexOfActiveCard !== 0 && needSplitCards && isActiveEnemyCard) ||\r\n      (firstItemIsClosed && needSplitCards)\r\n  );\r\n\r\n  const isActivePlayerDead =\r\n    deadPlayerList && deadPlayerList[activePlayerNumber] ? true : false;\r\n\r\n  const enemyElem = enemyListOnCell.map(([index, enemyCard]) => {\r\n    return (\r\n      <EnemyCard\r\n        enemyCard={enemyCard}\r\n        key={index}\r\n        order={index}\r\n        isCurrent={\r\n          isActivePlayerDead\r\n            ? Boolean(currEnemyIndex && String(currEnemyIndex) === index)\r\n            : false\r\n        }\r\n        needSplitCards={needSplitCards}\r\n        needReverseCards={needReverseCards}\r\n        apperance={enemyCard.appearance}\r\n        refList={cardRef}\r\n      />\r\n    );\r\n  });\r\n\r\n  const hasTwoCard = Boolean(enemyCardsOnCell.length && hasInventoryCards);\r\n\r\n  return (\r\n    <CardList needSplitCards={hasTwoCard}>\r\n      {type === \"inventory\" ? null : enemyElem}\r\n      {inventoryElem}\r\n    </CardList>\r\n  );\r\n});\r\n","import { Player } from \"../../components\";\r\n\r\nimport { PlayerListType, GameState, State } from \"../../business/types\";\r\nimport { useSelector } from \"react-redux\";\r\n\r\nexport const PlayerList = ({ coord }: { coord: string }) =>\r\n  // playersList: PlayerListType,\r\n  // numberOfPlayer: number,\r\n  // gameState: GameState,\r\n  // isPlayerAlone: boolean\r\n  {\r\n    const playerList = useSelector((state: State) => state.playerList);\r\n    const activePlayerNumber = useSelector(\r\n      (state: State) => state.activePlayerNumber\r\n    );\r\n\r\n    const playerItemList = Object.entries(playerList);\r\n\r\n    const playerListOnCell = playerItemList\r\n      .filter((playerItem) => {\r\n        const [, playerCard] = playerItem;\r\n        return playerCard.coord === coord && playerCard.name === \"player\";\r\n      })\r\n      .map((playerItem) => {\r\n        const [, playerCard] = playerItem;\r\n        return playerCard;\r\n      });\r\n\r\n    const hasPlayerOnCell = playerListOnCell.length > 0;\r\n\r\n    switch (hasPlayerOnCell) {\r\n      case true: {\r\n        return (\r\n          <Player\r\n            playerListOnCell={playerListOnCell}\r\n            playerList={playerList}\r\n            numberOfPlayer={activePlayerNumber}\r\n            // gameState={gameState}\r\n            // isPlayerAlone={isPlayerAlone}\r\n          />\r\n        );\r\n      }\r\n      case false: {\r\n        return null;\r\n      }\r\n    }\r\n  };\r\n","import React, { useMemo } from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\nimport { useSelector } from \"react-redux\";\r\nimport styled from \"styled-components\";\r\n\r\nimport { PlayGridMode, State } from \"../../business/types\";\r\nimport { CellItem } from \"../../components/CellItem\";\r\n\r\nimport { Barrier } from \"./Barrier\";\r\nimport { CardListEl } from \"./CardListEl\";\r\nimport { PlayerList } from \"./PlayerList\";\r\n\r\ntype CellApperance = {\r\n  needHighlightning?: boolean;\r\n  mode: PlayGridMode;\r\n};\r\n\r\ntype PlanType = \"back\" | \"front\";\r\ntype CardsListType = \"all\" | \"enemy\" | \"inventory\";\r\n\r\ntype UnderlayerType = {\r\n  coordX: string;\r\n  coordY: string;\r\n};\r\n\r\nconst Wrap = styled.div`\r\n  position: relative;\r\n`;\r\n\r\nconst CardListWrap = styled.div<{ needSplitCards: boolean }>`\r\n  display: flex;\r\n  flex-wrap: nowrap;\r\n  position: absolute;\r\n\r\n  > * {\r\n    position: ${(props) => {\r\n      if (props.needSplitCards) {\r\n        return \"relative \";\r\n      }\r\n    }};\r\n\r\n    margin: ${(props) => {\r\n      if (props.needSplitCards) {\r\n        return \"0 -12px\";\r\n      }\r\n    }};\r\n    /* \r\n    flex-direction: ${(props) => {\r\n      if (props.needSplitCards) {\r\n        return \"row-reverse\";\r\n      } else {\r\n        return \"row\";\r\n      }\r\n    }}; */\r\n  }\r\n`;\r\n\r\nconst UnderlayerItem = styled.div<UnderlayerType>`\r\n  position: relative;\r\n  display: flex;\r\n  width: 134px;\r\n  height: 100px;\r\n  background-color: rgb(47 84 96 / 77%);\r\n  left: -30px;\r\n  bottom: 120px;\r\n  flex-direction: row;\r\n  justify-content: center;\r\n  border-radius: 10px;\r\n  box-shadow: 0px 0px 12px 1px rgb(62 76 81 / 98%);\r\n\r\n  left: ${(props) => {\r\n    return `${Number(props.coordX) * 50 - 30}px`;\r\n  }};\r\n\r\n  bottom: ${(props) => {\r\n    return `${Number(props.coordY) * 50 + 70}px`;\r\n  }};\r\n\r\n  & > * {\r\n    position: relative !important;\r\n    margin: 30px 0;\r\n    width: 50px;\r\n    height: 50px;\r\n    z-index: 3;\r\n  }\r\n\r\n  flex-direction: row;\r\n  align-items: center;\r\n  z-index: 6;\r\n`;\r\n\r\n//принимает только буквально координату\r\n//через селекторы сама решает что рисовать\r\n\r\n/**\r\n * 1. player   +\r\n * 6.walls===barrier (сейчас просто картинка)\r\n * 2.enemy\r\n * 3.inventory\r\n * 4.split\r\n * 5.separate window\r\n */\r\n\r\n/**\r\n * 1. Есть ли активная карточка на ячейка- нет=> только background\r\n * 2. Достаем все карточки на ячейке\r\n */\r\nexport const Cell: React.FC<{\r\n  coord: string;\r\n  mode: PlayGridMode;\r\n}> = React.memo(function _Cell({ coord, mode /* , cardRef */ }) {\r\n  const cellValues = useSelector(\r\n    (state: State) => state.gameField.values[coord]\r\n  );\r\n\r\n  const hasActivePlayerOnCell: boolean = useSelector(\r\n    (state: State) =>\r\n      state.playerList[state.activePlayerNumber]?.coord === coord\r\n  );\r\n\r\n  const hasActiveDeadPlayerOnCell: boolean = useSelector((state: State) => {\r\n    const hasEnemyCard = Object.values(state.enemyList).find(\r\n      (enemyItem) => enemyItem.coord === coord\r\n    );\r\n    return Boolean(hasEnemyCard);\r\n  });\r\n\r\n  /**\r\n   * considering hasActivePlayerOnCell\r\n   */\r\n  const isPhaseEnemyInteract = useSelector(\r\n    (state: State) =>\r\n      hasActivePlayerOnCell &&\r\n      state.gameState.type.includes(\"interactWithEnemy\")\r\n  );\r\n\r\n  const isPhaseEnemyMove = useSelector(\r\n    (state: State) =>\r\n      hasActiveDeadPlayerOnCell && state.gameState.type.includes(\"enemyMove\")\r\n  );\r\n\r\n  const additionalUpdate = useSelector(\r\n    (state: State) => state.gameState.type === \"gameStarted.rollDice\"\r\n  );\r\n\r\n  if (isPhaseEnemyMove) console.log(\"isPhaseEnemyMove\");\r\n\r\n  const needHighlightning = useSelector((state: State) =>\r\n    state.gameState.coordOfAvailableCells\r\n      ? state.gameState.coordOfAvailableCells.includes(coord)\r\n      : false\r\n  );\r\n\r\n  const isPlayerMoveArea = useSelector((state: State) => {\r\n    const playerMovePhase =\r\n      state.gameState.type === \"gameStarted.playerMove\" ||\r\n      state.gameState.type === \"enemyMove\";\r\n\r\n    return playerMovePhase && needHighlightning;\r\n  });\r\n\r\n  console.log(isPlayerMoveArea, \"isPlayerMoveArea\");\r\n\r\n  /**\r\n   * considering hasActivePlayerOnCell\r\n   */\r\n  const isPhaseTakeCard = useSelector(\r\n    (state: State) =>\r\n      hasActivePlayerOnCell && state.gameState.type === \"gameStarted.takeCard\"\r\n  );\r\n\r\n  const isNeedCreateSeparateWindow =\r\n    isPhaseEnemyInteract || isPhaseTakeCard; /* ||\r\n    isPhaseEnemyMove */ /* || isPhasePlayerMove */\r\n\r\n  const enemyList = useSelector((state: State) => state.enemyList);\r\n  const deadPlayerList = useSelector((state: State) => state.deadPlayerList);\r\n\r\n  const hasInventoryCards = useSelector((state: State) => {\r\n    const playerCoord = state.playerList[state.activePlayerNumber]?.coord;\r\n    const enemyOrderNumber = state.deadPlayerList\r\n      ? state.deadPlayerList[state.activePlayerNumber]?.index\r\n      : undefined;\r\n\r\n    const enemyPlayerCoord =\r\n      enemyOrderNumber &&\r\n      state.enemyList[enemyOrderNumber] &&\r\n      state.enemyList[enemyOrderNumber].coord;\r\n\r\n    const hasInventory =\r\n      (playerCoord && state.gameField.values[playerCoord].cardItem?.length) ||\r\n      (enemyPlayerCoord &&\r\n        state.gameField.values[enemyPlayerCoord].cardItem?.length);\r\n\r\n    return hasInventory;\r\n  });\r\n  const [hor, vert] = coord.split(\".\");\r\n\r\n  const draftCellNumbers = mode === \"cssStyle\" ? `${hor}.${vert}` : null;\r\n\r\n  const memoizedBarrier = useMemo(() => {\r\n    return <Barrier orderIndex={coord} mode={mode}></Barrier>;\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, []);\r\n\r\n  const fieildElem = document.getElementById(\"field\");\r\n\r\n  const getCardList = ({\r\n    type,\r\n    planType,\r\n  }: {\r\n    type: CardsListType | null;\r\n    planType: PlanType;\r\n  }) => {\r\n    const enemyListOnCell = Object.entries(enemyList).filter(\r\n      ([string, enemyCard]) => {\r\n        return enemyCard.coord === coord;\r\n      }\r\n    );\r\n\r\n    const hasTwoCard =\r\n      false; /* Boolean(enemyListOnCell.length && hasInventoryCards); */\r\n\r\n    /**\r\n     * если задни план и фаза - игрока не рисуем\r\n     * иначе на заднем\\переднем рисуем\r\n     */\r\n    const cardList = (\r\n      <>\r\n        {planType === \"back\" && isNeedCreateSeparateWindow ? null : (\r\n          <PlayerList coord={coord} />\r\n        )}\r\n        <CardListEl\r\n          cell={cellValues}\r\n          type={type as CardsListType}\r\n          currCoord={coord}\r\n          enemyList={enemyList}\r\n          deadPlayerList={deadPlayerList}\r\n        />\r\n      </>\r\n    );\r\n\r\n    return hasTwoCard ? (\r\n      <CardListWrap needSplitCards={true}>{cardList}</CardListWrap>\r\n    ) : (\r\n      cardList\r\n    );\r\n  };\r\n\r\n  const getCardListType = ({\r\n    type,\r\n  }: {\r\n    type: PlanType;\r\n  }): CardsListType | null => {\r\n    switch (type) {\r\n      /**\r\n       * если передний план\r\n       * вз-е с врагом - на первом плане враг\r\n       * вз-е с карточкой -карточка\r\n       * иначе ничего\r\n       *\r\n       * если задний- все наоборот\r\n       */\r\n      case \"front\": {\r\n        if (hasActivePlayerOnCell) {\r\n          switch (true) {\r\n            case isPhaseEnemyInteract: {\r\n              return \"enemy\";\r\n            }\r\n            case isPhaseTakeCard: {\r\n              return \"inventory\";\r\n            }\r\n            default: {\r\n              return null;\r\n            }\r\n          }\r\n        } else {\r\n          return null;\r\n        }\r\n      }\r\n      case \"back\": {\r\n        if (hasActivePlayerOnCell) {\r\n          switch (true) {\r\n            case isPhaseEnemyInteract: {\r\n              return \"inventory\";\r\n            }\r\n            case isPhaseTakeCard: {\r\n              return \"enemy\";\r\n            }\r\n            default: {\r\n              return \"all\";\r\n            }\r\n          }\r\n        } else {\r\n          return \"all\";\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  const getCardsOnCell = ({ type }: { type: PlanType }) => {\r\n    const cardListType = getCardListType({ type });\r\n\r\n    const cardListWithPlayer = getCardList({\r\n      type: cardListType,\r\n      planType: type,\r\n    });\r\n\r\n    return cardListWithPlayer;\r\n  };\r\n\r\n  const foregroundPortal = fieildElem\r\n    ? ReactDOM.createPortal(\r\n        <>\r\n          <UnderlayerItem coordX={hor} coordY={vert}>\r\n            {getCardsOnCell({ type: \"front\" })}\r\n          </UnderlayerItem>\r\n        </>,\r\n        fieildElem\r\n      )\r\n    : null;\r\n\r\n  const backgroundCardWrap = (\r\n    <Wrap key={`${hor}.${vert}`}>\r\n      <CellItem\r\n        needHighlightning={needHighlightning}\r\n        mode={mode}\r\n        hor={hor}\r\n        vert={vert}\r\n      >\r\n        {draftCellNumbers}\r\n        {getCardsOnCell({ type: \"back\" })}\r\n      </CellItem>\r\n      {memoizedBarrier}\r\n    </Wrap>\r\n  );\r\n\r\n  console.log(isNeedCreateSeparateWindow, \"isNeedCreateSeparateWindow\");\r\n  const cellItem: JSX.Element = useMemo(() => {\r\n    return (\r\n      <React.Fragment key={`${hor}.${vert}`}>\r\n        {backgroundCardWrap}\r\n        {isNeedCreateSeparateWindow ? foregroundPortal : null}\r\n      </React.Fragment>\r\n    );\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, [\r\n    hasActivePlayerOnCell,\r\n    isPhaseEnemyInteract,\r\n    isPhaseTakeCard,\r\n    needHighlightning,\r\n    hasActiveDeadPlayerOnCell,\r\n    isPlayerMoveArea,\r\n    isPhaseEnemyMove,\r\n  ]);\r\n\r\n  return cellItem;\r\n});\r\n","import React, { useMemo } from \"react\";\r\nimport styled from \"styled-components\";\r\nimport { useSelector } from \"react-redux\";\r\n\r\nimport { State } from \"../../business/types\";\r\nimport { Cell } from \"./Cell\";\r\n\r\nconst Wrap = styled.div`\r\n  position: relative;\r\n`;\r\n\r\nexport const FilledPlayGrid: React.FC = React.memo(function _FilledPlayGrid() {\r\n  const orderGameCells = useSelector((state: State) => state.gameField.order);\r\n  const _config = useSelector((state: State) => state._config);\r\n  // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  const memoConfig = useMemo(() => _config, []);\r\n\r\n  const fullPlayerGrid = orderGameCells.map((orderIndex: string) => {\r\n    const [hor, vert] = orderIndex.split(\".\");\r\n    return (\r\n      <Wrap key={`${hor}.${vert}`}>\r\n        <Cell coord={orderIndex} mode={memoConfig.playGridMode} />\r\n      </Wrap>\r\n    );\r\n  });\r\n\r\n  // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  const memoizedPlayerGrid = useMemo(() => fullPlayerGrid, []);\r\n\r\n  return <>{memoizedPlayerGrid}</>;\r\n});\r\n","import React, { useMemo } from \"react\";\r\nimport { memo } from \"react\";\r\nimport { useSelector } from \"react-redux\";\r\nimport styled from \"styled-components\";\r\n\r\nimport { State, PlayGridMode } from \"../../business/types\";\r\nimport { FilledPlayGrid } from \"./FilledPlayGrid\";\r\n\r\nimport img from \"./house_2.png\";\r\n\r\ntype GridProps = {\r\n  vert: number;\r\n  mode: PlayGridMode;\r\n};\r\n\r\nconst GridItem = styled.div<GridProps>`\r\n  outline: ${(props) => {\r\n    if (props.mode === \"cssStyle\") {\r\n      return \"2px solid lightgray\";\r\n    }\r\n  }};\r\n\r\n  margin: 0 auto;\r\n  width: 100%;\r\n  transform: rotate(270deg);\r\n  display: grid;\r\n  grid-column-start: -1;\r\n  //параметризирую по ширине поля\r\n  grid-template-columns: ${(props) => {\r\n    return `repeat(${props.vert} ,50px)`;\r\n  }};\r\n\r\n  grid-gap: 0px;\r\n  > * {\r\n    transform: rotate(90deg);\r\n  }\r\n\r\n  background-image: ${(props) => {\r\n    if (props.mode === \"image\") {\r\n      return `url(${img})`;\r\n    }\r\n  }};\r\n\r\n  background-color: white;\r\n  background-size: 600px;\r\n  box-shadow: 0 0 10px rgb(0 0 0 / 50%);\r\n`;\r\n\r\ntype PlayGridProps = {\r\n  className?: string;\r\n  test?: string;\r\n};\r\n\r\nexport const PlayGrid: React.FC<PlayGridProps> = React.memo(function _PlayGrid({\r\n  className,\r\n  test,\r\n}) {\r\n  const config = useSelector((state: State) => state._config);\r\n\r\n  const { vert: maxVert } = config.finishCoord;\r\n  const height = maxVert + 1;\r\n\r\n  const MemoizedFilledPlayGrid = useMemo(() => <FilledPlayGrid />, []);\r\n\r\n  return (\r\n    <GridItem key={\"grid\"} vert={height} mode={config.playGridMode}>\r\n      {MemoizedFilledPlayGrid}\r\n    </GridItem>\r\n  );\r\n});\r\n","export default \"data:image/png;base64,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\"","import { useSelector } from \"react-redux\";\r\n\r\nimport styled from \"styled-components\";\r\n\r\nimport { State, PlayerListType } from \"../business/types\";\r\n\r\nconst MAX_HEALTH_AMOUNT = 7;\r\n\r\ntype HealthSlotType = {\r\n  isFilled: boolean;\r\n};\r\n\r\nconst HealthSlotList = styled.div`\r\n  display: flex;\r\n  align-items: center;\r\n`;\r\nconst HealthSlot = styled.div<HealthSlotType>`\r\n  width: 5px;\r\n  height: 5px;\r\n  border-radius: 50%;\r\n  border: 1px solid #f09292;\r\n  margin: 1px;\r\n  background-color: ${(props) => {\r\n    if (props.isFilled) {\r\n      return \"#f09292\";\r\n    } else return \"none\";\r\n  }};\r\n`;\r\n\r\nexport const HealthSlots = (props: { index: number }) => {\r\n  const playerList = useSelector((state: State) => state.playerList);\r\n\r\n  return (\r\n    <HealthSlotList>\r\n      {getHealthSlot(playerList, props.index).map(\r\n        (healthSlotFilled: boolean, index: number) => {\r\n          return (\r\n            <HealthSlot key={index} isFilled={healthSlotFilled}></HealthSlot>\r\n          );\r\n        }\r\n      )}\r\n    </HealthSlotList>\r\n  );\r\n};\r\n\r\nconst getHealthSlot = (playerList: PlayerListType, index: number) => {\r\n  const playerHealth = getPlayerHealth(playerList, index);\r\n  const maxHealthSlotList = new Array(MAX_HEALTH_AMOUNT).fill(0);\r\n\r\n  const filledHealthSlotList = maxHealthSlotList.reduce(\r\n    (prev, currSlot, index) => {\r\n      if (index < playerHealth) {\r\n        return [...prev, true];\r\n      } else {\r\n        return [...prev, false];\r\n      }\r\n    },\r\n    []\r\n  );\r\n  return filledHealthSlotList;\r\n};\r\n\r\nconst getPlayerHealth = (\r\n  playersList: PlayerListType,\r\n  numberOfPlayer: number\r\n) => {\r\n  return playersList[numberOfPlayer].health;\r\n};\r\n","import { useDispatch, useSelector } from \"react-redux\";\r\n\r\nimport styled from \"styled-components\";\r\n\r\nimport { State, InventoryType, TypeOfInventoryCard } from \"../business/types\";\r\n\r\nimport health from \"../components/Health/health.png\";\r\nimport boards from \"../components/Boards/boards.png\";\r\nimport weapon from \"../components/Weapon/weapon.png\";\r\n\r\ntype ImageType = {\r\n  type: TypeOfInventoryCard;\r\n  highlighting?: boolean;\r\n};\r\n\r\nconst InventoryWrap = styled.div`\r\n  display: flex;\r\n  flex-direction: row;\r\n  flex-wrap: wrap;\r\n  align-content: flex-start;\r\n`;\r\n\r\nconst InwentoryRow = styled.div`\r\n  display: flex;\r\n  width: 100%;\r\n  flex-wrap: nowrap;\r\n  align-items: center;\r\n`;\r\n\r\n//Todo: can replace switch to calculated props?\r\nconst Image = styled.div<ImageType>`\r\n  width: 50px;\r\n  height: 50px;\r\n  background-size: 44px;\r\n  background-repeat: no-repeat;\r\n  background-position: 3px;\r\n  background-image: ${(props) => {\r\n    switch (props.type) {\r\n      case \"health\": {\r\n        return `url(${health})`;\r\n      }\r\n\r\n      case \"boards\": {\r\n        return `url(${boards})`;\r\n      }\r\n\r\n      case \"weapon\": {\r\n        return `url(${weapon})`;\r\n      }\r\n    }\r\n  }};\r\n  outline: ${(props) => {\r\n    if (props.highlighting === true) {\r\n      return \"1px solid red \";\r\n    }\r\n  }};\r\n`;\r\n\r\nconst Counter = styled.div`\r\n  margin-left: 10px;\r\n  font-size: 22px;\r\n`;\r\n\r\nexport const Inventory = (props: { index: number }) => {\r\n  const dispatch = useDispatch();\r\n  const playerList = useSelector((state: State) => state.playerList);\r\n\r\n  const inventory: InventoryType = playerList[props.index].inventory;\r\n\r\n  return (\r\n    <InventoryWrap>\r\n      <InwentoryRow>\r\n        <Image\r\n          type=\"health\"\r\n          highlighting={inventory.cardSelected === \"health\"}\r\n          onClick={() => {\r\n            dispatch({\r\n              type: \"cardChoosed\",\r\n              payload: { type: \"health\" },\r\n            });\r\n          }}\r\n        ></Image>\r\n        <Counter> x {inventory[\"health\"] || 0}</Counter>\r\n      </InwentoryRow>\r\n      <InwentoryRow>\r\n        <Image\r\n          type=\"boards\"\r\n          highlighting={inventory.cardSelected === \"boards\"}\r\n          onClick={() => {\r\n            dispatch({\r\n              type: \"cardChoosed\",\r\n              payload: { type: \"boards\" },\r\n            });\r\n          }}\r\n        ></Image>\r\n        <Counter> x {inventory[\"boards\"] || 0}</Counter>\r\n      </InwentoryRow>\r\n      <InwentoryRow>\r\n        <Image\r\n          type=\"weapon\"\r\n          highlighting={inventory.cardSelected === \"weapon\"}\r\n          onClick={() => {\r\n            dispatch({\r\n              type: \"cardChoosed\",\r\n              payload: { type: \"weapon\" },\r\n            });\r\n          }}\r\n        ></Image>\r\n        <Counter> x {inventory[\"weapon\"] || 0}</Counter>\r\n      </InwentoryRow>\r\n\r\n      <InwentoryRow></InwentoryRow>\r\n      <InwentoryRow></InwentoryRow>\r\n    </InventoryWrap>\r\n  );\r\n};\r\n","import { useSelector } from \"react-redux\";\r\n\r\nimport styled from \"styled-components\";\r\n\r\nimport { State } from \"../business/types\";\r\n\r\nimport { HealthSlots } from \"../components/HealthSlots\";\r\nimport { Inventory } from \"../components/Inventory\";\r\n\r\nimport player from \"../components/Player/player.png\";\r\nimport player2 from \"../components/Player/player2.png\";\r\nimport player3 from \"../components/Player/player3.png\";\r\nimport player4 from \"../components/Player/player4.png\";\r\n\r\ntype avatarType = { image: string };\r\n\r\nconst PlayerStatusCard = styled.div`\r\n  width: 250px;\r\n  height: 240px;\r\n  border: 1px solid lightgray;\r\n  padding: 10px;\r\n  box-sizing: border-box;\r\n  display: flex;\r\n  /*  justify-content: center; */\r\n  background-color: white;\r\n  flex-wrap: wrap;\r\n`;\r\n\r\n//eslint-disable-next-line\r\nconst CharacterAvatar = styled.div<avatarType>`\r\n  width: 50px;\r\n  height: 50px;\r\n  border: 1px solid lightgray;\r\n  font-size: 14px;\r\n  text-align: center;\r\n  background-repeat: no-repeat;\r\n  background-position: 0px;\r\n  background-size: 44px;\r\n  background-position: 3px;\r\n  background-image: ${(props) => {\r\n    return `url(${props.image})`;\r\n  }};\r\n`;\r\n\r\nconst Status = styled.div`\r\n  display: flex;\r\n  border: 1px solid lightgray;\r\n\r\n  padding: 3px;\r\n  margin-bottom: 15px;\r\n  font-size: 14px;\r\n  width: 150px;\r\n`;\r\n\r\nconst HealthStatus = styled(Status)`\r\n  height: 20px;\r\n  margin: 15px 5px;\r\n`;\r\n\r\nconst InventoryStatus = styled(Status)`\r\n  /*   height: 100px; */\r\n`;\r\n\r\nconst Row = styled.div`\r\n  display: flex;\r\n  flex-direction: row;\r\n`;\r\n\r\nexport const PlayerStatus = () => {\r\n  // const { activePlayerNumber, playerList } = useSelector((state: State) => ({\r\n  //   ...state,\r\n  // }));\r\n\r\n  const activePlayerNumber = useSelector(\r\n    (state: State) => state.activePlayerNumber\r\n  );\r\n  const playerList = useSelector((state: State) => state.playerList);\r\n\r\n  const playerImageList = [player, player2, player3, player4];\r\n\r\n  // TODO: why pass the index?\r\n\r\n  const avatar = (\r\n    <CharacterAvatar image={playerImageList[activePlayerNumber]}>\r\n      {`${activePlayerNumber + 1}`}\r\n    </CharacterAvatar>\r\n  );\r\n  const health = (\r\n    <HealthStatus>\r\n      {`здоровье:  `}\r\n      <HealthSlots index={activePlayerNumber}></HealthSlots>\r\n    </HealthStatus>\r\n  );\r\n  const inventory = (\r\n    <InventoryStatus>\r\n      <Inventory index={activePlayerNumber} />\r\n    </InventoryStatus>\r\n  );\r\n\r\n  const isAlivePlayer = playerList[activePlayerNumber] ? true : false;\r\n\r\n  switch (isAlivePlayer) {\r\n    case true: {\r\n      return (\r\n        <PlayerStatusCard>\r\n          <Row>\r\n            {avatar}\r\n            {health}\r\n          </Row>\r\n          <Row>{inventory}</Row>\r\n        </PlayerStatusCard>\r\n      );\r\n    }\r\n    case false: {\r\n      return (\r\n        <PlayerStatusCard>\r\n          <Row>\r\n            {avatar}\r\n            <HealthStatus>{<div>Dead</div>}</HealthStatus>\r\n          </Row>\r\n        </PlayerStatusCard>\r\n      );\r\n    }\r\n  }\r\n};\r\n","import { useSelector } from \"react-redux\";\r\nimport { useState, useEffect } from \"react\";\r\n\r\nimport styled from \"styled-components\";\r\n\r\nimport { State, GameState, TypeEffect } from \"../business/types\";\r\n\r\nimport { PlayerStatus } from \"./PlayerStatus\";\r\n\r\nconst Status = styled.div`\r\n  width: 200px;\r\n  min-height: 18px;\r\n  width: 250px;\r\n  height: 100px;\r\n  border: 1px solid lightgray;\r\n  background-color: #fff2d9;\r\n  text-align: center;\r\n  font-size: 20px;\r\n  color: #5f5757;\r\n  padding-top: 15px;\r\n  box-sizing: border-box;\r\n`;\r\n\r\nexport const StatusList = () => {\r\n  type statusType = string;\r\n  const initialStatus: statusType = \"\";\r\n  const [status, updateStatus] = useState(initialStatus);\r\n\r\n  const dice = useSelector((state: State) => state.dice);\r\n  const gameState = useSelector((state: State) => state.gameState);\r\n  const doEffect = useSelector((state: State) => state.doEffect);\r\n  const gameResult = useSelector((state: State) => state.gameResult);\r\n\r\n  const newStatus = getTextStatus(gameState, doEffect, dice, gameResult);\r\n  const battlePhrase = \"pежим боя\";\r\n  useEffect(() => {\r\n    updateStatus(() => {\r\n      if (gameState.type.includes(\"interactWithEnemy\")) {\r\n        if (gameState.type === \"interactWithEnemy\") {\r\n          return newStatus;\r\n        } else {\r\n          return `${battlePhrase}: ${newStatus}`;\r\n        }\r\n      } else {\r\n        return newStatus;\r\n      }\r\n    });\r\n  }, [gameState.type, doEffect?.type, newStatus]);\r\n  return (\r\n    <>\r\n      <Status>{status}</Status>\r\n      <PlayerStatus />\r\n    </>\r\n  );\r\n};\r\n\r\nconst getTextStatus = (\r\n  gameState: GameState,\r\n  doEffect: TypeEffect,\r\n  dice: number,\r\n  gameResult: string\r\n) => {\r\n  switch (gameState.type) {\r\n    case \"gameStarted.rollDice\":\r\n      return \"бросить кубик\";\r\n    case \"gameStarted.playerMove\":\r\n      return \"сделать ход\";\r\n    case \"gameStarted.takeCard\":\r\n      return \"открываем карточку\";\r\n    case \"gameStarted.applyCard\":\r\n      return \"применить карточку\";\r\n\r\n    /*   case \"interactWithEnemy.applyCard\":\r\n      return \"применить оружие\"; */\r\n    case \"interactWithEnemy.throwBattleDice\": {\r\n      return \"бросить кубик\";\r\n    }\r\n    case \"interactWithEnemy.applyCard\": {\r\n      return \"применить оружие\";\r\n    }\r\n\r\n    case \"interactWithEnemy.makeBattleAction\":\r\n    case \"interactWithEnemy\":\r\n      switch (doEffect?.type) {\r\n        case \"!openEnemyCard\": {\r\n          return \"открываем карточку\";\r\n        }\r\n\r\n        case \"!getBattleResult\": {\r\n          switch (dice) {\r\n            case 1:\r\n            case 2: {\r\n              return `выпало ${dice}: игрок применяет оружие или бросает кубик `;\r\n            }\r\n            case 3: {\r\n              return `выпало ${dice}: игрок теряет 1 здоровье`;\r\n            }\r\n            case 4: {\r\n              return `выпало ${dice}: игрок спасается бегством `;\r\n            }\r\n            default:\r\n              return \"бросить кубик или применить оружие\";\r\n          }\r\n        }\r\n        default:\r\n          return \"сделать ход\";\r\n      }\r\n\r\n    /*   case \"gameStarted.interactWithEnemy.fightOrKeepBattle\":\r\n      return \"применить  оружие или бросить кубик\"; */\r\n    case \"enemyMove.chooseEnemy\": {\r\n      return \"выбрать карточку врага\";\r\n    }\r\n    case \"enemyMove\": {\r\n      return \"передвинуть карточку врага\";\r\n    }\r\n    case \"endGame\":\r\n      return gameResult;\r\n    default:\r\n      return \"\";\r\n  }\r\n};\r\n","import React from \"react\";\r\nimport { useSelector } from \"react-redux\";\r\n\r\nimport styled from \"styled-components\";\r\n\r\nimport { State } from \"../business/types\";\r\n\r\nconst GameScore = styled.div`\r\n  margin: 100px;\r\n`;\r\n\r\nexport const EndScreen = () => {\r\n  const gameResult = useSelector((state: State) => state.gameResult);\r\n  return (\r\n    <>\r\n      <GameScore>Игра окончена. {gameResult}</GameScore>\r\n    </>\r\n  );\r\n};\r\n","import React from \"react\";\r\n\r\nimport styled from \"styled-components\";\r\n\r\n/* import {amountPlayers } from \"../shared/config/devConfig\"; */\r\nimport { HealthSlots } from \"../components/HealthSlots\";\r\nimport { Inventory } from \"../components/Inventory\";\r\nimport { ConfigType } from \"../business/types\";\r\n\r\ntype AmountOfPlayers = {\r\n  amount: number;\r\n};\r\n\r\nconst PlayersListWrap = styled.div<AmountOfPlayers>`\r\n  /*  width: 130px; */\r\n  width: 100%;\r\n  height: 100px;\r\n  /*   border: 1px solid lightgray; */\r\n  display: grid;\r\n\r\n  grid-template-rows: 20% auto auto;\r\n  grid-template-columns: ${(props) => {\r\n    return `repeat(${props.amount} ,25px)`;\r\n  }};\r\n  pointer-events: none;\r\n`;\r\n\r\nconst CharacterAvatar = styled.div`\r\n  font-size: 12px;\r\n  text-align: center;\r\n  grid-row-start: 1;\r\n  grid-row-end: 2;\r\n`;\r\n\r\nconst HealthSlotsWrap = styled.div`\r\n  grid-row-start: 2;\r\n  grid-row-end: 3;\r\n  & > * {\r\n    display: flex;\r\n    flex-direction: column;\r\n    align-items: center;\r\n    flex-direction: column;\r\n    width: 100%;\r\n  }\r\n`;\r\n\r\nconst InventorysWrap = styled.div`\r\n  grid-row-start: 3;\r\n  grid-row-end: 4;\r\n  & * {\r\n    display: flex;\r\n    flex-direction: column;\r\n    align-items: center;\r\n    flex-direction: column;\r\n    box-sizing: border-box;\r\n    outline: none;\r\n    /*  & > * {\r\n      box-sizing: border-box;\r\n    } */\r\n  }\r\n`;\r\n\r\nexport const PlayersStatusList = (config: ConfigType) => {\r\n  return (\r\n    <PlayersListWrap amount={config.amountPlayers}>\r\n      {new Array(config.amountPlayers).fill(0).map((player, index) => {\r\n        return (\r\n          <React.Fragment key={index}>\r\n            <CharacterAvatar>{`${index + 1}`}</CharacterAvatar>\r\n            <HealthSlotsWrap>\r\n              <HealthSlots index={index}></HealthSlots>\r\n            </HealthSlotsWrap>\r\n            <InventorysWrap>\r\n              <Inventory index={index} />\r\n            </InventorysWrap>\r\n          </React.Fragment>\r\n        );\r\n      })}\r\n    </PlayersListWrap>\r\n  );\r\n};\r\n","import { useDispatch } from \"react-redux\";\r\n\r\nimport styled from \"styled-components\";\r\n\r\nconst StartButton = styled.button`\r\n  height: 22px;\r\n  margin: 140px;\r\n`;\r\n\r\nexport const StartScreen = () => {\r\n  const dispatch = useDispatch();\r\n  return (\r\n    <>\r\n      <StartButton\r\n        onClick={() => {\r\n          dispatch({ type: \"clickedStartButton\" });\r\n        }}\r\n      >\r\n        {\" \"}\r\n        начать игру\r\n      </StartButton>\r\n    </>\r\n  );\r\n};\r\n","import {\r\n  StartCell,\r\n  CommonCell,\r\n  FinishCell,\r\n  GameFieldCells,\r\n  CellType,\r\n  ConfigType,\r\n} from \"../../types\";\r\n\r\n/**\r\n *  Returns an object with start and finish  in structure of GameValues.\r\n */\r\nexport const getFieldCells = (\r\n  cellList: string[],\r\n  config: ConfigType\r\n): GameFieldCells => {\r\n  const emptyFieldCells = createEmptyFieldCells(cellList);\r\n  const fieldCellsWithWalls = getCellsWalls(emptyFieldCells, config);\r\n  const organizedFieldCells = getOrganizedFieldCells(\r\n    fieldCellsWithWalls,\r\n    config\r\n  );\r\n  return organizedFieldCells;\r\n};\r\n\r\n/**\r\n * Creates an object with keys and empty cells in structure of GameValues.\r\n */\r\nconst createEmptyFieldCells = (cellList: Array<string>): GameFieldCells => {\r\n  const emptyFieldItem: CommonCell = {\r\n    name: \"commonCell\",\r\n    cardItem: [],\r\n  };\r\n\r\n  let newEmptyGameField: GameFieldCells = {};\r\n\r\n  cellList.forEach((cell: string) => {\r\n    newEmptyGameField[cell] = emptyFieldItem;\r\n  });\r\n\r\n  return newEmptyGameField;\r\n};\r\n\r\n/**\r\n *  Creates an object with start, finish and walls in structure of GameValues.\r\n */\r\nconst getOrganizedFieldCells = (\r\n  emptyField: GameFieldCells,\r\n  config: ConfigType\r\n): GameFieldCells => {\r\n  const startIndex = `${config.startCoord.hor}.${config.startCoord.vert}`;\r\n  const finishIndex = `${config.finishCoord.hor}.${config.finishCoord.vert}`;\r\n\r\n  const startCell: StartCell = {\r\n    name: \"start\",\r\n    cardItem: [],\r\n  };\r\n\r\n  const finishCell: FinishCell = {\r\n    name: \"finish\",\r\n    cardItem: [],\r\n  };\r\n\r\n  const organizedGameFieldCells = {\r\n    ...emptyField,\r\n    [startIndex]: startCell,\r\n    [finishIndex]: finishCell,\r\n  };\r\n\r\n  return organizedGameFieldCells;\r\n};\r\n\r\n/**\r\n * @returns The object in structure GameFieldCells. With walls(barriers) in cells.\r\n */\r\nconst getCellsWalls = (\r\n  emptyField: GameFieldCells,\r\n  config: ConfigType\r\n): GameFieldCells => {\r\n  // TODO: Need add checking for CommonCell?\r\n\r\n  /**\r\n   * Returns list of Cells with walls(barriers)\r\n   */\r\n  const cellsWithBarrierList = config.cellsBarrierList.map(\r\n    (cellBarrier): [string, CellType] => {\r\n      const { coord, barrierList } = cellBarrier;\r\n      const cellIndex = `${coord.hor}.${coord.vert}`;\r\n\r\n      const cellWithoutBarrier = emptyField[cellIndex];\r\n\r\n      if (cellWithoutBarrier.name === \"commonCell\") {\r\n        const cellWithBarrier = {\r\n          ...cellWithoutBarrier,\r\n          barrierList: barrierList,\r\n        };\r\n\r\n        return [cellIndex, cellWithBarrier];\r\n      } else {\r\n        return [cellIndex, cellWithoutBarrier];\r\n      }\r\n    }\r\n  );\r\n\r\n  const cellsWithBarriers: GameFieldCells =\r\n    Object.fromEntries(cellsWithBarrierList);\r\n\r\n  const fieldCellsWithWalls = { ...emptyField, ...cellsWithBarriers };\r\n  return fieldCellsWithWalls;\r\n};\r\n","import { CommonCell, GameFieldCells, CardItem, ConfigType } from \"../../types\";\r\n/* \r\nimport {\r\n amountHealthItems,\r\n  amountBoardsItems,\r\n  cardAppearance,\r\n  amountWeaponsItems,\r\n} from \"../../../shared/config/devConfig\";\r\n */\r\ntype CardSet = {\r\n  card: CardItem;\r\n  amount: number;\r\n};\r\n\r\nconst getCardList = (config: ConfigType): CardSet[] => {\r\n  return [\r\n    {\r\n      card: {\r\n        name: \"health\",\r\n        appearance: config.cardAppearance,\r\n      },\r\n      amount: config.amountHealthItems,\r\n    },\r\n    {\r\n      card: {\r\n        name: \"boards\",\r\n        appearance: config.cardAppearance,\r\n      },\r\n      amount: config.amountBoardsItems,\r\n    },\r\n    {\r\n      card: {\r\n        name: \"weapon\",\r\n        appearance: config.cardAppearance,\r\n      },\r\n      amount: config.amountWeaponsItems,\r\n    },\r\n  ];\r\n};\r\n/**\r\n * Returns an object in structure of FieldCells with spreaded cards in random picked cells.\r\n */\r\nexport const spreadCards = (\r\n  gameFieldCells: GameFieldCells,\r\n  config: ConfigType\r\n): GameFieldCells => {\r\n  /**\r\n   * filledСells - its object with filling cells\r\n   * currCardSet -curr set of cards\r\n   * from cardset making object with cards\r\n   */\r\n\r\n  const cardsList = getCardList(config);\r\n  const cellsWithAllCards = cardsList.reduce((filledCells, currCardSet) => {\r\n    const gameFieldCellsWithPrevious = { ...gameFieldCells, ...filledCells };\r\n\r\n    const cellsForCards = getListForCards(\r\n      gameFieldCellsWithPrevious,\r\n      currCardSet\r\n    );\r\n\r\n    /**\r\n     * Adding filled with previos cardSet cells\r\n     */\r\n    const filledWithCardsFieldCells = setCards(cellsForCards, currCardSet);\r\n    const filledWithAllCardsCells = {\r\n      ...filledCells,\r\n      ...filledWithCardsFieldCells,\r\n    };\r\n    return filledWithAllCardsCells;\r\n  }, {});\r\n\r\n  const gameFieldFull = { ...gameFieldCells, ...cellsWithAllCards };\r\n  return gameFieldFull;\r\n};\r\n\r\n/**\r\n *  Creates an object with spreaded cards into cells from cellsForCards.\r\n */\r\nconst setCards = (\r\n  cellList: [string, CommonCell][],\r\n  currCardSet: CardSet\r\n): GameFieldCells => {\r\n  const cellListWithCards = cellList.map(\r\n    (cellWithCards: [string, CommonCell]) => {\r\n      const [index, cell] = cellWithCards;\r\n\r\n      const cellWithCard: CommonCell = {\r\n        ...cell,\r\n        cardItem: [currCardSet.card],\r\n      };\r\n      return [index, cellWithCard];\r\n    }\r\n  );\r\n\r\n  const fieldCellsWithCards = Object.fromEntries(cellListWithCards);\r\n\r\n  return fieldCellsWithCards;\r\n};\r\n\r\n/**\r\n * Returns an array with random empty cell witch suitable for card.\r\n * Array lenght is equal AMOUNT_..._ITEMS.\r\n */\r\nconst getListForCards = (\r\n  gameField: GameFieldCells,\r\n  currCardSet: CardSet\r\n): [string, CommonCell][] => {\r\n  const listGameField = Object.entries(gameField);\r\n\r\n  /**\r\n   * This array contains only empty cells\r\n   */\r\n\r\n  const emptyCellsList = listGameField.filter(\r\n    (cellItem): cellItem is [string, CommonCell] => {\r\n      const [, item] = cellItem;\r\n\r\n      return item.name === \"commonCell\" && item.cardItem?.length === 0;\r\n    }\r\n  );\r\n\r\n  const AMOUNT_EMPTY_CELLS = emptyCellsList.length;\r\n  const amoutCurrentCards = currCardSet.amount;\r\n\r\n  const canSetAllCards = amoutCurrentCards < AMOUNT_EMPTY_CELLS;\r\n  const remainingAmountCards = AMOUNT_EMPTY_CELLS;\r\n\r\n  const afforableAmountCards = canSetAllCards\r\n    ? amoutCurrentCards\r\n    : remainingAmountCards;\r\n\r\n  if (!canSetAllCards) {\r\n    const cardName = currCardSet.card?.name;\r\n    console.error(`Cards \"${cardName}\" more than empty cell.`);\r\n  }\r\n\r\n  /**\r\n   * Is a list with number of indexes of empty cells.\r\n   */\r\n  const keyList: Array<number> = new Array(afforableAmountCards)\r\n    .fill(0)\r\n    .reduce((prevkeyList) => {\r\n      const randomNumber = getRandomNumber(prevkeyList, AMOUNT_EMPTY_CELLS);\r\n\r\n      if (prevkeyList) {\r\n        return [...prevkeyList, randomNumber];\r\n      } else {\r\n        return [randomNumber];\r\n      }\r\n    }, []);\r\n\r\n  const listForCards = keyList.map((keyItem: number): [string, CommonCell] => {\r\n    return emptyCellsList[keyItem];\r\n  });\r\n\r\n  return listForCards;\r\n};\r\n\r\n/**\r\n * Gets an array with the previously selected random numbers and the maximum number to select.\r\n * Returns a random number satisfying the conditions.\r\n */\r\nconst getRandomNumber = (\r\n  arrNumber: Array<number>,\r\n  maxNumber: number\r\n): number => {\r\n  const number = Math.floor(Math.random() * maxNumber);\r\n\r\n  if (arrNumber) {\r\n    return arrNumber.includes(number)\r\n      ? getRandomNumber(arrNumber, maxNumber)\r\n      : number;\r\n  } else {\r\n    return number;\r\n  }\r\n};\r\n","import { ConfigType } from \"../../types\";\r\nimport { getFieldCells } from \"./getFieldCells\";\r\nimport { spreadCards } from \"./spreadCards\";\r\n\r\n//TODO: Need add some config object for all cards and spreading them simultaneously.\r\nexport const getGameField = (config: ConfigType) => {\r\n  const order = getCellOrder(config);\r\n  const gameFieldCells = getFieldCells(order, config);\r\n  const filledWithCardsCells = spreadCards(gameFieldCells, config);\r\n  const gameField = { order, values: filledWithCardsCells };\r\n  return gameField;\r\n};\r\n\r\n/**\r\n * Creates an array with cell index order.\r\n */\r\nconst getCellOrder = (config: any): Array<string> => {\r\n  const width = config.finishCoord.hor;\r\n  const height = config.finishCoord.vert;\r\n\r\n  let orderList: Array<string> = [];\r\n\r\n  for (let hor = 0; hor <= width; hor++) {\r\n    for (let vert = 0; vert <= height; vert++) {\r\n      const index: string = `${hor}.${vert}`;\r\n      orderList.push(index);\r\n    }\r\n  }\r\n\r\n  return orderList;\r\n};\r\n","import { ConfigType, PlayerListType } from \"../types\";\r\n\r\nexport const getPlayers = (config: ConfigType): PlayerListType => {\r\n  const startCoord = `${config.startCoord.hor}.${config.startCoord.vert}`;\r\n  const playersList = new Array(config.amountPlayers)\r\n    .fill(0)\r\n    .map((player, index) => {\r\n      const playerCard = {\r\n        name: \"player\",\r\n        health: config.initialPlayerHealth,\r\n        orderNumber: index,\r\n        coord: startCoord,\r\n        //TODO: Added const emptyInventory\r\n        inventory: { boards: 0, weapon: 0, health: 0, cardSelected: null },\r\n      };\r\n      return [index, playerCard];\r\n    });\r\n\r\n  const playersObj: PlayerListType = Object.fromEntries(playersList);\r\n  return playersObj;\r\n};\r\n","import {\r\n  EnemyListType,\r\n  GameField,\r\n  CommonCell,\r\n  ConfigType,\r\n  EnemyCardType,\r\n} from \"../types\";\r\n\r\nexport const getEnemies = (\r\n  gameField: GameField,\r\n  config: ConfigType\r\n): EnemyListType => {\r\n  const emptyCellsList = getEmptyList(gameField);\r\n  const enemiesCoords = getListOfIndexes(emptyCellsList, config);\r\n  const enemiesObj = getListOfEnemy(enemiesCoords, config);\r\n  return enemiesObj;\r\n};\r\n\r\n/**\r\n * For every element checks that cell has no cards on it.\r\n * Returns the list of cells without any cards.\r\n */\r\nconst getEmptyList = (gameField: GameField): [string, CommonCell][] => {\r\n  const listCells = Object.entries(gameField.values);\r\n  const emptyCellsList = listCells.filter(\r\n    (cellItem): cellItem is [string, CommonCell] => {\r\n      const [, item] = cellItem;\r\n      return item.name === \"commonCell\" && item.cardItem?.length === 0;\r\n    }\r\n  );\r\n  return emptyCellsList;\r\n};\r\n\r\n/**\r\n * Returns the list of random picked indexes of emptyCellsList\r\n */\r\nconst getListOfIndexes = (\r\n  emptyCellsList: [string, CommonCell][],\r\n  config: ConfigType\r\n) => {\r\n  const AMOUNT_EMPTY_CELLS = emptyCellsList.length;\r\n  const amountEnemies = config.amountEnemies;\r\n\r\n  const canSetAllCards = amountEnemies < AMOUNT_EMPTY_CELLS;\r\n  const remainingAmountCards = AMOUNT_EMPTY_CELLS;\r\n\r\n  const afforableAmountCards = canSetAllCards\r\n    ? amountEnemies\r\n    : remainingAmountCards;\r\n\r\n  if (!canSetAllCards) {\r\n    console.error(`Cards \"enemy\" more than empty cell.`);\r\n  }\r\n\r\n  // TODO: it may be taking out as separate module with getRandomNumber?\r\n  const keyList: Array<number> = new Array(afforableAmountCards)\r\n    .fill(0)\r\n    .reduce((prevkeyList) => {\r\n      const randomNumber = getRandomNumber(prevkeyList, AMOUNT_EMPTY_CELLS);\r\n\r\n      if (prevkeyList) {\r\n        return [...prevkeyList, randomNumber];\r\n      } else {\r\n        return [randomNumber];\r\n      }\r\n    }, []);\r\n\r\n  const idexesListForCards = keyList.map((keyItem: number): string => {\r\n    const [index] = emptyCellsList[keyItem];\r\n    return index;\r\n  });\r\n\r\n  return idexesListForCards;\r\n};\r\n\r\n/**\r\n * Returns the object of all enemies\r\n */\r\nconst getListOfEnemy = (enemiesCoords: string[], config: ConfigType) => {\r\n  const enemyList = enemiesCoords.map((coord, index) => {\r\n    const enemyCard: EnemyCardType = {\r\n      name: \"enemy\",\r\n      power: 1,\r\n      coord,\r\n      appearance: config.cardAppearance,\r\n    };\r\n    return [index, enemyCard];\r\n  });\r\n\r\n  const enemiesObj: EnemyListType = Object.fromEntries(enemyList);\r\n  return enemiesObj;\r\n};\r\n\r\n/**\r\n * Gets an array with the previously selected random numbers and the maximum number to select.\r\n * Returns a random number satisfying the conditions.\r\n */\r\nconst getRandomNumber = (\r\n  arrNumber: Array<number>,\r\n  maxNumber: number\r\n): number => {\r\n  const number = Math.floor(Math.random() * maxNumber);\r\n\r\n  if (arrNumber) {\r\n    return arrNumber.includes(number)\r\n      ? getRandomNumber(arrNumber, maxNumber)\r\n      : number;\r\n  } else {\r\n    return number;\r\n  }\r\n};\r\n","import { CellsBarrierListType } from \"../../business/types\";\r\n\r\n// The array is convenient for iterating\r\nexport const CELLS_BARRIERS_LIST: CellsBarrierListType = [\r\n  {\r\n    coord: { hor: 2, vert: 2 },\r\n    barrierList: [\r\n      {\r\n        name: \"wall\",\r\n        direction: \"bottom\",\r\n      },\r\n      {\r\n        name: \"wall\",\r\n        direction: \"left\",\r\n      },\r\n    ],\r\n  },\r\n\r\n  {\r\n    coord: { hor: 2, vert: 3 },\r\n    barrierList: [\r\n      {\r\n        name: \"wall\",\r\n        direction: \"left\",\r\n      },\r\n    ],\r\n  },\r\n\r\n  {\r\n    coord: { hor: 2, vert: 4 },\r\n    barrierList: [\r\n      {\r\n        name: \"wall\",\r\n        direction: \"left\",\r\n      },\r\n    ],\r\n  },\r\n\r\n  {\r\n    coord: { hor: 2, vert: 5 },\r\n    barrierList: [\r\n      {\r\n        name: \"window\",\r\n        direction: \"left\",\r\n        isOpen: true,\r\n      },\r\n    ],\r\n  },\r\n\r\n  {\r\n    coord: { hor: 2, vert: 6 },\r\n    barrierList: [\r\n      {\r\n        name: \"wall\",\r\n        direction: \"left\",\r\n      },\r\n    ],\r\n  },\r\n\r\n  {\r\n    coord: { hor: 2, vert: 7 },\r\n    barrierList: [\r\n      {\r\n        name: \"wall\",\r\n        direction: \"bottom\",\r\n      },\r\n      {\r\n        name: \"wall\",\r\n        direction: \"left\",\r\n      },\r\n    ],\r\n  },\r\n\r\n  {\r\n    coord: { hor: 2, vert: 8 },\r\n    barrierList: [\r\n      {\r\n        name: \"window\",\r\n        direction: \"left\",\r\n        isOpen: true,\r\n      },\r\n    ],\r\n  },\r\n\r\n  {\r\n    coord: { hor: 2, vert: 9 },\r\n    barrierList: [\r\n      {\r\n        name: \"wall\",\r\n        direction: \"left\",\r\n      },\r\n    ],\r\n  },\r\n\r\n  {\r\n    coord: { hor: 2, vert: 10 },\r\n    barrierList: [\r\n      {\r\n        name: \"wall\",\r\n        direction: \"bottom\",\r\n      },\r\n    ],\r\n  },\r\n\r\n  {\r\n    coord: { hor: 3, vert: 10 },\r\n    barrierList: [\r\n      {\r\n        name: \"wall\",\r\n        direction: \"bottom\",\r\n      },\r\n    ],\r\n  },\r\n  {\r\n    coord: { hor: 4, vert: 10 },\r\n    barrierList: [\r\n      {\r\n        name: \"wall\",\r\n        direction: \"bottom\",\r\n      },\r\n    ],\r\n  },\r\n  {\r\n    coord: { hor: 5, vert: 10 },\r\n    barrierList: [\r\n      {\r\n        name: \"door\",\r\n        direction: \"bottom\",\r\n        isOpen: true,\r\n      },\r\n    ],\r\n  },\r\n  {\r\n    coord: { hor: 6, vert: 10 },\r\n    barrierList: [\r\n      {\r\n        name: \"wall\",\r\n        direction: \"bottom\",\r\n      },\r\n    ],\r\n  },\r\n  {\r\n    coord: { hor: 7, vert: 10 },\r\n    barrierList: [\r\n      {\r\n        name: \"wall\",\r\n        direction: \"bottom\",\r\n      },\r\n    ],\r\n  },\r\n\r\n  {\r\n    coord: { hor: 8, vert: 10 },\r\n    barrierList: [\r\n      {\r\n        name: \"wall\",\r\n        direction: \"bottom\",\r\n      },\r\n    ],\r\n  },\r\n\r\n  {\r\n    coord: { hor: 9, vert: 10 },\r\n    barrierList: [\r\n      {\r\n        name: \"wall\",\r\n        direction: \"bottom\",\r\n      },\r\n    ],\r\n  },\r\n  {\r\n    coord: { hor: 10, vert: 10 },\r\n    barrierList: [\r\n      {\r\n        name: \"wall\",\r\n        direction: \"bottom\",\r\n      },\r\n    ],\r\n  },\r\n  {\r\n    coord: { hor: 7, vert: 9 },\r\n    barrierList: [\r\n      {\r\n        name: \"wall\",\r\n        direction: \"left\",\r\n      },\r\n    ],\r\n  },\r\n\r\n  {\r\n    coord: { hor: 3, vert: 2 },\r\n    barrierList: [\r\n      {\r\n        name: \"wall\",\r\n        direction: \"bottom\",\r\n      },\r\n    ],\r\n  },\r\n\r\n  {\r\n    coord: { hor: 4, vert: 2 },\r\n    barrierList: [\r\n      {\r\n        name: \"door\",\r\n        direction: \"bottom\",\r\n        isOpen: true,\r\n      },\r\n    ],\r\n  },\r\n\r\n  {\r\n    coord: { hor: 5, vert: 2 },\r\n    barrierList: [\r\n      {\r\n        name: \"window\",\r\n        direction: \"bottom\",\r\n        isOpen: true,\r\n      },\r\n    ],\r\n  },\r\n  {\r\n    coord: { hor: 6, vert: 2 },\r\n    barrierList: [\r\n      {\r\n        name: \"wall\",\r\n        direction: \"bottom\",\r\n      },\r\n    ],\r\n  },\r\n  {\r\n    coord: { hor: 7, vert: 2 },\r\n    barrierList: [\r\n      {\r\n        name: \"wall\",\r\n        direction: \"bottom\",\r\n      },\r\n      {\r\n        name: \"wall\",\r\n        direction: \"left\",\r\n      },\r\n    ],\r\n  },\r\n\r\n  {\r\n    coord: { hor: 8, vert: 2 },\r\n    barrierList: [\r\n      {\r\n        name: \"window\",\r\n        direction: \"bottom\",\r\n        isOpen: true,\r\n      },\r\n    ],\r\n  },\r\n  {\r\n    coord: { hor: 9, vert: 2 },\r\n    barrierList: [\r\n      {\r\n        name: \"wall\",\r\n        direction: \"bottom\",\r\n      },\r\n    ],\r\n  },\r\n\r\n  {\r\n    coord: { hor: 10, vert: 2 },\r\n    barrierList: [\r\n      {\r\n        name: \"wall\",\r\n        direction: \"bottom\",\r\n      },\r\n    ],\r\n  },\r\n\r\n  {\r\n    coord: { hor: 10, vert: 7 },\r\n    barrierList: [\r\n      {\r\n        name: \"wall\",\r\n        direction: \"bottom\",\r\n      },\r\n    ],\r\n  },\r\n\r\n  {\r\n    coord: { hor: 3, vert: 7 },\r\n    barrierList: [\r\n      {\r\n        name: \"wall\",\r\n        direction: \"bottom\",\r\n      },\r\n    ],\r\n  },\r\n  {\r\n    coord: { hor: 4, vert: 9 },\r\n    barrierList: [\r\n      {\r\n        name: \"wall\",\r\n        direction: \"left\",\r\n      },\r\n    ],\r\n  },\r\n\r\n  {\r\n    coord: { hor: 4, vert: 8 },\r\n    barrierList: [\r\n      {\r\n        name: \"wall\",\r\n        direction: \"left\",\r\n      },\r\n    ],\r\n  },\r\n  {\r\n    coord: { hor: 4, vert: 7 },\r\n    barrierList: [\r\n      {\r\n        name: \"door\",\r\n        direction: \"left\",\r\n        isOpen: true,\r\n      },\r\n      {\r\n        name: \"door\",\r\n        direction: \"bottom\",\r\n        isOpen: true,\r\n      },\r\n    ],\r\n  },\r\n\r\n  {\r\n    coord: { hor: 5, vert: 7 },\r\n    barrierList: [\r\n      {\r\n        name: \"wall\",\r\n        direction: \"bottom\",\r\n      },\r\n    ],\r\n  },\r\n  {\r\n    coord: { hor: 6, vert: 7 },\r\n    barrierList: [\r\n      {\r\n        name: \"wall\",\r\n        direction: \"bottom\",\r\n      },\r\n    ],\r\n  },\r\n  {\r\n    coord: { hor: 7, vert: 7 },\r\n    barrierList: [\r\n      {\r\n        name: \"wall\",\r\n        direction: \"left\",\r\n      },\r\n      {\r\n        name: \"wall\",\r\n        direction: \"bottom\",\r\n      },\r\n    ],\r\n  },\r\n\r\n  {\r\n    coord: { hor: 7, vert: 8 },\r\n    barrierList: [\r\n      {\r\n        name: \"door\",\r\n        direction: \"left\",\r\n        isOpen: true,\r\n      },\r\n    ],\r\n  },\r\n  {\r\n    coord: { hor: 8, vert: 7 },\r\n    barrierList: [\r\n      {\r\n        name: \"wall\",\r\n        direction: \"bottom\",\r\n      },\r\n    ],\r\n  },\r\n  {\r\n    coord: { hor: 9, vert: 7 },\r\n    barrierList: [\r\n      {\r\n        name: \"door\",\r\n        direction: \"bottom\",\r\n        isOpen: true,\r\n      },\r\n    ],\r\n  },\r\n  {\r\n    coord: { hor: 7, vert: 6 },\r\n    barrierList: [\r\n      {\r\n        name: \"wall\",\r\n        direction: \"left\",\r\n      },\r\n    ],\r\n  },\r\n  {\r\n    coord: { hor: 7, vert: 5 },\r\n    barrierList: [\r\n      {\r\n        name: \"door\",\r\n        direction: \"left\",\r\n        isOpen: true,\r\n      },\r\n    ],\r\n  },\r\n  {\r\n    coord: { hor: 7, vert: 4 },\r\n    barrierList: [\r\n      {\r\n        name: \"wall\",\r\n        direction: \"left\",\r\n      },\r\n    ],\r\n  },\r\n  {\r\n    coord: { hor: 7, vert: 3 },\r\n    barrierList: [\r\n      {\r\n        name: \"wall\",\r\n        direction: \"left\",\r\n      },\r\n    ],\r\n  },\r\n\r\n  {\r\n    coord: { hor: 11, vert: 9 },\r\n    barrierList: [\r\n      {\r\n        name: \"wall\",\r\n        direction: \"left\",\r\n      },\r\n    ],\r\n  },\r\n\r\n  {\r\n    coord: { hor: 11, vert: 8 },\r\n    barrierList: [\r\n      {\r\n        name: \"window\",\r\n        direction: \"left\",\r\n        isOpen: true,\r\n      },\r\n    ],\r\n  },\r\n  {\r\n    coord: { hor: 11, vert: 7 },\r\n    barrierList: [\r\n      {\r\n        name: \"wall\",\r\n        direction: \"left\",\r\n      },\r\n    ],\r\n  },\r\n  {\r\n    coord: { hor: 11, vert: 6 },\r\n    barrierList: [\r\n      {\r\n        name: \"wall\",\r\n        direction: \"left\",\r\n      },\r\n    ],\r\n  },\r\n  {\r\n    coord: { hor: 11, vert: 5 },\r\n    barrierList: [\r\n      {\r\n        name: \"window\",\r\n        direction: \"left\",\r\n        isOpen: true,\r\n      },\r\n    ],\r\n  },\r\n  {\r\n    coord: { hor: 11, vert: 4 },\r\n    barrierList: [\r\n      {\r\n        name: \"wall\",\r\n        direction: \"left\",\r\n      },\r\n    ],\r\n  },\r\n  {\r\n    coord: { hor: 11, vert: 3 },\r\n    barrierList: [\r\n      {\r\n        name: \"wall\",\r\n        direction: \"left\",\r\n      },\r\n    ],\r\n  },\r\n  {\r\n    coord: { hor: 11, vert: 2 },\r\n    barrierList: [\r\n      {\r\n        name: \"wall\",\r\n        direction: \"left\",\r\n      },\r\n    ],\r\n  },\r\n\r\n  //it is needed for now for pretty  wall painting\r\n  /*   {\r\n    coord: { hor: 11, vert: 10 },\r\n    barrierList: [\r\n      {\r\n        name: null,\r\n        direction: \"left\",\r\n        isOpen: true,\r\n      },\r\n    ],\r\n  }, */\r\n];\r\n","import { ConfigType, State } from \"../types\";\r\n\r\nimport { getGameField } from \"./getGameField\";\r\nimport { getPlayers } from \"./getPlayers\";\r\nimport { getEnemies } from \"./getEnemies\";\r\n\r\nimport { PROD_CONFIG, DEV_CONFIG } from \"../../shared/config\";\r\n\r\nexport const getInitialState = (config: ConfigType): State => {\r\n  //отдаем gameFieldWithoutEnemy для рандомного выбора координат врагов из пустых ячеек\r\n  const gameFieldWithoutEnemy = getGameField(config);\r\n  return {\r\n    gameState: {\r\n      type: \"waitingStart\",\r\n      coordOfAvailableCells: null,\r\n      coordOfAvailableCards: null,\r\n    },\r\n    dice: 0,\r\n    gameResult: \"\",\r\n    playerList: getPlayers(config),\r\n    enemyList: getEnemies(gameFieldWithoutEnemy, config),\r\n    gameField: gameFieldWithoutEnemy,\r\n    doEffect: null,\r\n    activePlayerNumber: 0,\r\n    deadPlayerList: null,\r\n    _config: config,\r\n  };\r\n};\r\n\r\nconst getConfig = (\r\n  PROD_CONFIG: ConfigType,\r\n  DEV_CONFIG: ConfigType\r\n): ConfigType => {\r\n  if (process.env.NODE_ENV === \"production\") {\r\n    return PROD_CONFIG;\r\n  } else if (process.env.NODE_ENV === \"development\") {\r\n    return DEV_CONFIG;\r\n  } else {\r\n    return PROD_CONFIG;\r\n  }\r\n};\r\n\r\nexport const config = getConfig(PROD_CONFIG, DEV_CONFIG);\r\n\r\nexport const initialState = getInitialState(config);\r\n","import { ConfigType } from \"../../business/types\";\r\n\r\nimport { CELLS_BARRIERS_LIST } from \"./walls\";\r\n\r\nexport const PROD_CONFIG: ConfigType = {\r\n  cellsBarrierList: CELLS_BARRIERS_LIST,\r\n  startCoord: { hor: 0, vert: 0 },\r\n  finishCoord: { hor: 11, vert: 11 },\r\n  amountPlayers: 2,\r\n  initialPlayerHealth: 3,\r\n  amountHealthItems: 20,\r\n  amountBoardsItems: 20,\r\n  amountWeaponsItems: 20,\r\n  amountEnemies: 20,\r\n  cardAppearance: \"closed\",\r\n  playGridMode: \"image\",\r\n};\r\n","import { State } from \"../../types\";\r\nimport { ActionType } from \"../../reducer\";\r\n\r\nexport const waitingStart = (state: State, action: ActionType): State => {\r\n  switch (action.type) {\r\n    case \"clickedStartButton\": {\r\n      return {\r\n        ...state,\r\n        gameState: { ...state.gameState, type: \"gameStarted.rollDice\" },\r\n      };\r\n    }\r\n    default:\r\n      return state;\r\n  }\r\n};\r\n","import {\r\n  AvailableCellListType,\r\n  AvailableCellType,\r\n  GameField,\r\n  MoveDirectionList,\r\n} from \"../../types\";\r\nimport { getNextPlayerCoord } from \"./getNextPlayerCoord\";\r\n\r\nexport const MOVE_DIRECTION_LIST: MoveDirectionList = [\r\n  \"top\",\r\n  \"right\",\r\n  \"bottom\",\r\n  \"left\",\r\n];\r\n\r\n/**\r\n * Returns the coordinates of neighboribgCells that lying in the GameField.\r\n */\r\nexport const getNeighboringCellListMax = (\r\n  prevPlayerCoord: string,\r\n  gameField: GameField,\r\n  dice: number\r\n): AvailableCellListType => {\r\n  const coordNeighboringCells: AvailableCellListType = MOVE_DIRECTION_LIST.map(\r\n    (directionItem) => {\r\n      return {\r\n        direction: directionItem,\r\n        coord: getNextPlayerCoord(prevPlayerCoord, directionItem),\r\n      };\r\n    }\r\n  );\r\n\r\n  const getCoordNeibCells = (coord: string) => {\r\n    const coordList = MOVE_DIRECTION_LIST.map((directionItem) => {\r\n      const newCoord = getNextPlayerCoord(coord, directionItem);\r\n      return newCoord;\r\n    });\r\n\r\n    return coordList;\r\n  };\r\n\r\n  type InitCoordObjType = {\r\n    list: Array<string>;\r\n    counter: number;\r\n  };\r\n\r\n  const getTakeableCoord = (\r\n    MOVE_DIRECTION_LIST: MoveDirectionList,\r\n    dice: number,\r\n    initPlayerCoord: string\r\n  ) => {\r\n    let takeableCoordList: InitCoordObjType = {\r\n      list: [initPlayerCoord],\r\n      counter: dice,\r\n    };\r\n\r\n    for (let i = 0; i < dice; i++) {\r\n      const currList = takeableCoordList.list.reduce(\r\n        (prev: Array<string>, coord) => {\r\n          const currCoordList = getCoordNeibCells(coord);\r\n\r\n          const listWithoutInitCoord = currCoordList.filter(\r\n            (coord) => coord !== initPlayerCoord\r\n          );\r\n\r\n          const existingInFieldCoord = listWithoutInitCoord.filter(\r\n            (coord) => gameField.values[coord]\r\n          );\r\n\r\n          if (prev.length > 1) {\r\n            const coordWithoutRepeat = existingInFieldCoord.filter(\r\n              (existCoord) => {\r\n                return !prev.includes(existCoord);\r\n              }\r\n            );\r\n\r\n            return [...prev, ...coordWithoutRepeat];\r\n          } else {\r\n            return existingInFieldCoord;\r\n          }\r\n        },\r\n        takeableCoordList.list\r\n      );\r\n\r\n      takeableCoordList = {\r\n        list: [...currList],\r\n        counter: dice - 1,\r\n      };\r\n    }\r\n\r\n    return takeableCoordList;\r\n  };\r\n\r\n  const testAbleCoord = getTakeableCoord(\r\n    MOVE_DIRECTION_LIST,\r\n    dice,\r\n    prevPlayerCoord\r\n  );\r\n\r\n  const testCells = [\r\n    ...coordNeighboringCells,\r\n    { direction: \"top\", coord: \"0.1\" },\r\n  ];\r\n\r\n  /**\r\n   * Returns the coordinates that lying in the GameField.\r\n   */\r\n  const existingInGameFieldCells: AvailableCellListType =\r\n    coordNeighboringCells.filter((cellItem) => {\r\n      const { coord } = cellItem;\r\n      return gameField.values[coord];\r\n    });\r\n\r\n  return existingInGameFieldCells;\r\n};\r\n\r\n// const testArr = [\r\n//   { direction: \"top\", coord: \"0.1\" },\r\n//   { direction: \"right\", coord: \"1.0\" },\r\n//   { direction: \"bottom\", coord: \"0.-1\" },\r\n//   { direction: \"left\", coord: \"-1.0\" },\r\n// ];\r\n","import { State, MoveDirection, CellType } from \"../../types\";\r\n\r\n/**\r\n * Returns true if current or next cell has wall\r\n */\r\nexport const checkCellHasWall = (\r\n  state: State,\r\n  newPlayerCoord: string,\r\n  direction: MoveDirection\r\n) => {\r\n  const {\r\n    playerList,\r\n    activePlayerNumber,\r\n    gameField,\r\n    deadPlayerList,\r\n    enemyList,\r\n  } = state;\r\n\r\n  /**\r\n   * Choose alive or dead player\r\n   */\r\n\r\n  const enemyIndex =\r\n    deadPlayerList &&\r\n    deadPlayerList[activePlayerNumber] &&\r\n    deadPlayerList[activePlayerNumber].index\r\n      ? deadPlayerList[activePlayerNumber].index\r\n      : null;\r\n\r\n  const currCellCoord = enemyIndex\r\n    ? enemyList[enemyIndex].coord\r\n    : playerList[activePlayerNumber].coord;\r\n\r\n  const currCell = gameField.values[currCellCoord];\r\n  const nextCell = gameField.values[newPlayerCoord];\r\n  const oppositeDirection = getOppositeDirection(direction);\r\n  const currCellHasBarrier = checkCellOnBarrier(currCell, direction);\r\n\r\n  const nextCellHasBarrier = checkCellOnBarrier(nextCell, oppositeDirection);\r\n\r\n  if (currCellHasBarrier || nextCellHasBarrier) {\r\n    return true;\r\n  } else {\r\n    return false;\r\n  }\r\n};\r\n\r\nconst checkCellOnBarrier = (cell: CellType, direction: MoveDirection) => {\r\n  if (cell.name === \"commonCell\") {\r\n    //Now in config just left and bottom walls\r\n    if (direction === \"left\" || direction === \"bottom\") {\r\n      const cellHasWall = cell.barrierList?.find(\r\n        (barrier) => barrier.name === \"wall\" && barrier.direction === direction\r\n      )\r\n        ? true\r\n        : false;\r\n      const cellHasClosedHole = cell.barrierList?.find(\r\n        (barrier) =>\r\n          (barrier.name !== \"wall\" && barrier.isOpen) === false &&\r\n          barrier.direction === direction\r\n      )\r\n        ? true\r\n        : false;\r\n      const cellHasBarrier = cellHasWall || cellHasClosedHole;\r\n      return cellHasBarrier;\r\n    }\r\n    return false;\r\n  }\r\n};\r\n\r\nconst getOppositeDirection = (direction: MoveDirection): MoveDirection => {\r\n  switch (direction) {\r\n    case \"top\": {\r\n      return \"bottom\";\r\n    }\r\n    case \"bottom\": {\r\n      return \"top\";\r\n    }\r\n    case \"left\": {\r\n      return \"right\";\r\n    }\r\n    case \"right\": {\r\n      return \"left\";\r\n    }\r\n  }\r\n};\r\n","import { State, MoveDirection, PlayerListType } from \"../../../types\";\r\n\r\nimport { checkCellHasWall } from \"../../common/checkCellHasWall\";\r\n/** Cheking the cases when can't take the cell. In default we think that can. */\r\nexport const checkCanTakeCell = (\r\n  state: State,\r\n  nextPlayerCoord: string,\r\n  direction: MoveDirection\r\n) => {\r\n  const { playerList, dice } = state;\r\n  const metBarrier = checkCellHasWall(state, nextPlayerCoord, direction);\r\n  const isLastStepOfMove = dice === 1;\r\n  const isNextCellOcupied = checkNextCellOccupied(playerList, nextPlayerCoord);\r\n  const canNotTakeCell = isLastStepOfMove && isNextCellOcupied;\r\n\r\n  switch (true) {\r\n    case metBarrier: {\r\n      return false;\r\n    }\r\n\r\n    case canNotTakeCell: {\r\n      // TODO: можно сделать промежуточное состояние для статуса с предупреждением о занятой чейке\r\n      return false;\r\n    }\r\n    default: {\r\n      return true;\r\n    }\r\n  }\r\n};\r\n\r\nconst checkNextCellOccupied = (\r\n  playersList: PlayerListType,\r\n  newCoord: string\r\n): boolean => {\r\n  const iterablePlayerList = Object.entries(playersList);\r\n  const isCellOccupied = iterablePlayerList.some((player) => {\r\n    const [, playerValue] = player;\r\n    return playerValue.coord === newCoord;\r\n  });\r\n  return isCellOccupied;\r\n};\r\n","import { AvailableCellListType, State } from \"../../../types\";\r\nimport { getNeighboringCellList } from \"../../common\";\r\nimport { getNeighboringCellListMax } from \"../../common/getNeighboringCellListMax\";\r\nimport { checkCanTakeCell } from \"./checkCanTakeCell\";\r\n\r\n/**\r\n * Current player get field \"availableForTake\" with coordinate of cells that can be taken\r\n */\r\nexport const getAvailableCellsMax = (state: State): State => {\r\n  const { playerList, activePlayerNumber, gameField, dice } = state;\r\n  const prevPlayerCoord = playerList[activePlayerNumber].coord;\r\n\r\n  const neighboringCellList = getNeighboringCellListMax(\r\n    prevPlayerCoord,\r\n    gameField,\r\n    dice\r\n  );\r\n\r\n  /**\r\n   * Returns the coordinates of Cell that can be taken by player.\r\n   */\r\n  const availableCellList: AvailableCellListType = neighboringCellList.filter(\r\n    (cellItem) => {\r\n      const { direction, coord } = cellItem;\r\n      //TODO: direction calculate from prevPlayerCoord and coord\r\n      return checkCanTakeCell(state, coord, direction);\r\n    }\r\n  );\r\n\r\n  const coordOfAvailableCells = availableCellList.map((cellItem) => {\r\n    const { coord } = cellItem;\r\n    return coord;\r\n  });\r\n\r\n  return {\r\n    ...state,\r\n    doEffect: null,\r\n    gameState: { ...state.gameState, coordOfAvailableCells },\r\n  };\r\n};\r\n","import { State } from \"../../types\";\r\n\r\nexport const getNextPlayerNumber = (state: State): number => {\r\n  const { playerList, deadPlayerList, activePlayerNumber, gameState } = state;\r\n  const { attackInitiator } = gameState;\r\n  const commonPlayerList = { ...playerList, ...deadPlayerList };\r\n  const playerListObj = Object.entries(commonPlayerList);\r\n\r\n  const maxPlayerNumber = playerListObj.length - 1;\r\n\r\n  const minPlayerNumber = 0;\r\n\r\n  if (attackInitiator || attackInitiator === 0) {\r\n    const nextPlayerNumber =\r\n      attackInitiator + 1 > maxPlayerNumber\r\n        ? minPlayerNumber\r\n        : attackInitiator + 1;\r\n\r\n    return nextPlayerNumber;\r\n  } else {\r\n    const nextPlayerNumber =\r\n      activePlayerNumber + 1 > maxPlayerNumber\r\n        ? minPlayerNumber\r\n        : activePlayerNumber + 1;\r\n    return nextPlayerNumber;\r\n  }\r\n};\r\n","import { State } from \"../../../types\";\r\n\r\nexport const changePlayerCoord = (state: State, newPlayerCoord: string) => {\r\n  const { playerList, activePlayerNumber } = state;\r\n\r\n  const newPlayerList = {\r\n    ...playerList,\r\n    [activePlayerNumber]: {\r\n      ...playerList[activePlayerNumber],\r\n      coord: newPlayerCoord,\r\n    },\r\n  };\r\n  return newPlayerList;\r\n};\r\n","import {\r\n  State,\r\n  PlayerListType,\r\n  TypeOfInventoryCard,\r\n  InventoryType,\r\n} from \"../../types\";\r\n\r\n/**\r\n * We need to give highlighting to healthCard\r\n */\r\n\r\nexport const getStateCardSelected = (\r\n  state: State,\r\n  typeOfSelect: TypeOfInventoryCard\r\n): State => {\r\n  // TODO: Need to restrict select unneceserry card -?!\r\n  // Add switch on type of cards\r\n  const { activePlayerNumber } = state;\r\n\r\n  const isCardNonZero = checkCardNonZero(state, typeOfSelect);\r\n\r\n  switch (isCardNonZero) {\r\n    case false: {\r\n      return state;\r\n    }\r\n\r\n    case true:\r\n      {\r\n        const newPlayerList = changeSelectedCard(state, typeOfSelect);\r\n        const selectedCard = newPlayerList[activePlayerNumber].inventory\r\n          .cardSelected\r\n          ? true\r\n          : false;\r\n\r\n        // The difference between weaponCard and other card that weapon are used in the battle.\r\n        //Obviously we need other stateWithoutSelectedCard for weapon\r\n        const stateWithSelectedCard: State = {\r\n          ...state,\r\n          playerList: newPlayerList,\r\n          gameState: {\r\n            ...state.gameState,\r\n            type: \"gameStarted.applyCard\",\r\n            coordOfAvailableCells: null,\r\n          },\r\n          doEffect: { type: \"!checkAvailableNeighboringCards\" },\r\n        };\r\n\r\n        const stateWithoutSelectedCard: State = {\r\n          ...state,\r\n          playerList: newPlayerList,\r\n          gameState: {\r\n            ...state.gameState,\r\n            coordOfAvailableCards: null,\r\n            type: /* cardType === \"weapon\"\r\n              ? \"gameStarted.interactWithEnemy\"\r\n              :  */ \"gameStarted.playerMove\",\r\n          },\r\n          doEffect: { type: \"!checkAvailableNeighboringCell\" },\r\n        };\r\n\r\n        switch (selectedCard) {\r\n          case true:\r\n            return stateWithSelectedCard;\r\n          case false:\r\n            return stateWithoutSelectedCard;\r\n        }\r\n      }\r\n      break;\r\n\r\n    default: {\r\n      return state;\r\n    }\r\n  }\r\n};\r\n\r\nconst changeSelectedCard = (\r\n  state: State,\r\n  typeOfSelect: TypeOfInventoryCard\r\n): PlayerListType => {\r\n  const { playerList, activePlayerNumber } = state;\r\n  const inventory = playerList[activePlayerNumber].inventory;\r\n\r\n  const isTheSameSelectType = inventory.cardSelected === typeOfSelect;\r\n\r\n  switch (isTheSameSelectType) {\r\n    case true: {\r\n      const newInventoryCardUnSelected: InventoryType = {\r\n        ...inventory,\r\n        cardSelected: null,\r\n      };\r\n\r\n      const newPlayerList: PlayerListType = {\r\n        ...playerList,\r\n        [activePlayerNumber]: {\r\n          ...playerList[activePlayerNumber],\r\n          inventory: newInventoryCardUnSelected,\r\n        },\r\n      };\r\n\r\n      return newPlayerList;\r\n    }\r\n\r\n    case false: {\r\n      const newInventoryCardSelected: InventoryType = {\r\n        ...inventory,\r\n        cardSelected: typeOfSelect,\r\n      };\r\n\r\n      const newPlayerList: PlayerListType = {\r\n        ...playerList,\r\n        [activePlayerNumber]: {\r\n          ...playerList[activePlayerNumber],\r\n          inventory: newInventoryCardSelected,\r\n        },\r\n      };\r\n\r\n      return newPlayerList;\r\n    }\r\n  }\r\n};\r\n\r\nconst checkCardNonZero = (\r\n  state: State,\r\n  typeOfSelect: TypeOfInventoryCard\r\n): Boolean => {\r\n  const { playerList, activePlayerNumber } = state;\r\n  const inventory = playerList[activePlayerNumber].inventory;\r\n  if (typeOfSelect !== null) {\r\n    const hasCards = inventory[typeOfSelect] !== 0;\r\n    return hasCards;\r\n  } else {\r\n    return false;\r\n  }\r\n};\r\n","import { State, TypeOfInventoryCard } from \"../../../types\";\r\n\r\nimport { ActionType } from \"../../../reducer\";\r\nimport { getAvailableCells } from \"./getAvailableCells\";\r\nimport { getAvailableCellsMax } from \"./getAvailableCellsMax\";\r\nimport { getPlayerMoveResult } from \"./getPlayerMoveResult\";\r\nimport { getStatePlayerMoved } from \"./getStatePlayerMoved\";\r\nimport { getStatePlayerMovedToCoord } from \"./getStatePlayerMovedToCoord\";\r\nimport { getStateCardSelected } from \"../../common/getStateCardSelected\";\r\n\r\nexport const playerMove = (state: State, action: ActionType): State => {\r\n  switch (action.type) {\r\n    case \"req-checkAvailableNeighboringCell\": {\r\n      return getAvailableCellsMax(state);\r\n    }\r\n\r\n    case \"playerWasMoved\": {\r\n      const newCoord = action.payload;\r\n      return getStatePlayerMovedToCoord(state, newCoord);\r\n    }\r\n\r\n    case \"moveControlsClicked\": {\r\n      const direction = action.payload;\r\n      return getStatePlayerMoved(state, direction);\r\n    }\r\n\r\n    case \"req-getPlayerMoveResult\": {\r\n      return getPlayerMoveResult(state);\r\n    }\r\n\r\n    //TODO: Rename to inventoryCardClicked-?!\r\n    case \"cardChoosed\": {\r\n      const TypeOfInventoryCard: TypeOfInventoryCard = action.payload.type;\r\n      return getStateCardSelected(state, TypeOfInventoryCard);\r\n    }\r\n\r\n    default: {\r\n      return state;\r\n    }\r\n  }\r\n};\r\n","import { CoordItem, State } from \"../../../types\";\r\nimport { getNextPlayerCoord } from \"../../common\";\r\nimport { changePlayerCoord } from \"./changePlayerCoord\";\r\n\r\n/**\r\n * Changing coordinates of player if he can take the cell in certain direction.\r\n */\r\nexport const getStatePlayerMovedToCoord = (\r\n  state: State,\r\n  newCoord: CoordItem\r\n): State => {\r\n  const { playerList, activePlayerNumber } = state;\r\n\r\n  //TODO: took out common functional for coordinates\r\n  const nextPlayerCoordString = Object.values(newCoord).join(\".\");\r\n\r\n  const canTakeNextCell = state.gameState.coordOfAvailableCells?.includes(\r\n    nextPlayerCoordString\r\n  );\r\n\r\n  switch (canTakeNextCell) {\r\n    case true: {\r\n      const newPlayerList = changePlayerCoord(state, nextPlayerCoordString);\r\n\r\n      const newState: State = {\r\n        ...state,\r\n        gameState: { ...state.gameState, coordOfAvailableCells: null },\r\n        playerList: newPlayerList,\r\n        doEffect: { type: \"!getPlayerMoveResult\" },\r\n      };\r\n      return newState;\r\n    }\r\n\r\n    case false: {\r\n      return state;\r\n    }\r\n\r\n    default: {\r\n      return state;\r\n    }\r\n  }\r\n};\r\n","import { MoveDirection, State } from \"../../../types\";\r\nimport { getNextPlayerCoord } from \"../../common\";\r\nimport { changePlayerCoord } from \"./changePlayerCoord\";\r\n\r\n/**\r\n * Changing coordinates of player if he can take the cell in certain direction.\r\n */\r\nexport const getStatePlayerMoved = (\r\n  state: State,\r\n  direction: MoveDirection\r\n): State => {\r\n  const { playerList, activePlayerNumber } = state;\r\n\r\n  const prevPlayerCoord = playerList[activePlayerNumber].coord;\r\n  const nextPlayerCoord = getNextPlayerCoord(prevPlayerCoord, direction);\r\n\r\n  const canTakeNextCell =\r\n    state.gameState.coordOfAvailableCells?.includes(nextPlayerCoord);\r\n\r\n  switch (canTakeNextCell) {\r\n    case true: {\r\n      const newPlayerList = changePlayerCoord(state, nextPlayerCoord);\r\n\r\n      const newState: State = {\r\n        ...state,\r\n        gameState: { ...state.gameState, coordOfAvailableCells: null },\r\n        playerList: newPlayerList,\r\n        doEffect: { type: \"!getPlayerMoveResult\" },\r\n      };\r\n\r\n      return newState;\r\n    }\r\n\r\n    case false: {\r\n      return state;\r\n    }\r\n\r\n    default: {\r\n      return state;\r\n    }\r\n  }\r\n};\r\n","import { State } from \"../../../types\";\r\nimport { getNextPlayerNumber } from \"../../common/getNextPlayerNumber\";\r\n\r\n/**\r\n * @returns  new state depending on the result of the player's movement.\r\n */\r\n\r\nexport const getPlayerMoveResult = (state: State) => {\r\n  const {\r\n    gameField,\r\n    playerList,\r\n    activePlayerNumber,\r\n    dice,\r\n    enemyList,\r\n    gameState,\r\n  } = state;\r\n\r\n  const newPlayerCoord = playerList[activePlayerNumber].coord;\r\n  const newCellWithPlayer = gameField.values[newPlayerCoord];\r\n  const isLastStepOfMove = dice === 1;\r\n\r\n  const takeFinish = newCellWithPlayer?.name === \"finish\";\r\n\r\n  const takeCard =\r\n    newCellWithPlayer?.name === \"commonCell\" &&\r\n    newCellWithPlayer.cardItem &&\r\n    newCellWithPlayer.cardItem?.length > 0;\r\n\r\n  const hasCurrCoordEnemy = Object.entries(enemyList).find(\r\n    ([index, enemyCard]) => {\r\n      return enemyCard.coord === newPlayerCoord;\r\n    }\r\n  );\r\n\r\n  //TODO: Why should i check commonCell-?!\r\n  const metEnemyCard =\r\n    newCellWithPlayer?.name === \"commonCell\" && hasCurrCoordEnemy\r\n      ? true\r\n      : false;\r\n\r\n  const { attackInitiator, ...newGameState } = gameState;\r\n\r\n  // TODO: Is flat switch okey? Or i need it nested?!\r\n  //TODO: add situation, when meet enemy and card on cell!\r\n  switch (true) {\r\n    case takeFinish: {\r\n      const newState: State = {\r\n        ...state,\r\n        dice: state.dice - 1,\r\n        gameResult: \"Вы выиграли\",\r\n        doEffect: null,\r\n      };\r\n      return newState;\r\n    }\r\n\r\n    case metEnemyCard: {\r\n      const newState: State = {\r\n        ...state,\r\n        dice: state.dice - 1,\r\n        gameState: {\r\n          ...newGameState,\r\n          type: \"interactWithEnemy\",\r\n        },\r\n        doEffect: { type: \"!checkAppearanceEnemyCard\" },\r\n      };\r\n      return newState;\r\n    }\r\n\r\n    case takeCard: {\r\n      const newState: State = {\r\n        ...state,\r\n        dice: state.dice - 1,\r\n        gameState: {\r\n          ...newGameState,\r\n          type: \"gameStarted.takeCard\",\r\n        },\r\n        doEffect: { type: \"!checkAppearanceInventoryCard\" },\r\n      };\r\n      return newState;\r\n    }\r\n\r\n    case isLastStepOfMove: {\r\n      const newPlayerNumber = getNextPlayerNumber(state);\r\n      const newState: State = {\r\n        ...state,\r\n        dice: 0,\r\n        gameState: {\r\n          ...newGameState,\r\n          type: \"gameStarted.rollDice\",\r\n        },\r\n        activePlayerNumber: newPlayerNumber,\r\n      };\r\n      return newState;\r\n    }\r\n\r\n    default: {\r\n      const newState: State = {\r\n        ...state,\r\n        dice: state.dice - 1,\r\n        gameState: { ...state.gameState, type: \"gameStarted.playerMove\" },\r\n        doEffect: { type: \"!checkAvailableNeighboringCell\" },\r\n      };\r\n      return newState;\r\n    }\r\n  }\r\n};\r\n","import {\r\n  State,\r\n  GameField,\r\n  PlayerListType,\r\n  InventoryType,\r\n  CardItem,\r\n} from \"../../../types\";\r\n\r\nimport { ActionType } from \"../../../reducer\";\r\nimport { openCard } from \"./openCard\";\r\nimport { deleteCard } from \"./deleteCard\";\r\nimport { getNextPlayerNumber } from \"../../common/getNextPlayerNumber\";\r\n\r\nexport const takeCard = (state: State, action: ActionType): State => {\r\n  switch (action.type) {\r\n    case \"req-checkInventoryCard\": {\r\n      return checkInventoryCardAppearance(state);\r\n    }\r\n\r\n    case \"req-openCard\": {\r\n      return getStateOpenCard(state);\r\n    }\r\n\r\n    case \"req-takeCard\": {\r\n      return getStateCardTaken(state);\r\n    }\r\n\r\n    case \"req-deleteCard\": {\r\n      return getStateDeletedCard(state);\r\n    }\r\n\r\n    default:\r\n      return state;\r\n  }\r\n};\r\n\r\nconst getStateOpenCard = (state: State): State => {\r\n  const { gameField, activePlayerNumber, playerList } = state;\r\n  const playerCoordIndex = playerList[activePlayerNumber].coord;\r\n  const currCell = gameField.values[playerCoordIndex];\r\n\r\n  const cellWithOpenCard = openCard(currCell);\r\n\r\n  const newGameField: GameField = {\r\n    ...gameField,\r\n    values: { ...gameField.values, [playerCoordIndex]: cellWithOpenCard },\r\n  };\r\n\r\n  return {\r\n    ...state,\r\n    gameField: newGameField,\r\n    doEffect: { type: \"!takeCard\" },\r\n  };\r\n};\r\n\r\nconst getStateCardTaken = (state: State): State => {\r\n  const { gameField, activePlayerNumber, playerList } = state;\r\n  const player = playerList[activePlayerNumber];\r\n\r\n  //We now for sure there is the card\r\n  const cardItems = gameField.values[player.coord].cardItem as CardItem[];\r\n\r\n  const emptyInventory = {\r\n    boards: 0,\r\n    health: 0,\r\n    weapon: 0,\r\n    cardSelected: null,\r\n  };\r\n\r\n  let structuredCardItems: InventoryType = cardItems.reduce(\r\n    (prevItem, currentItem) => {\r\n      if (currentItem) {\r\n        const prevItemObj = prevItem[currentItem.name];\r\n\r\n        if (prevItemObj) {\r\n          return {\r\n            ...prevItem,\r\n            [currentItem.name]: prevItem[currentItem.name] + 1,\r\n          };\r\n        } else {\r\n          return { ...prevItem, [currentItem.name]: 1 };\r\n        }\r\n      } else return emptyInventory;\r\n    },\r\n    emptyInventory\r\n  );\r\n\r\n  const newInventory = {\r\n    ...player.inventory,\r\n    boards: player.inventory.boards + structuredCardItems.boards,\r\n    health: player.inventory.health + structuredCardItems.health,\r\n    weapon: player.inventory.weapon + structuredCardItems.weapon,\r\n  };\r\n\r\n  const newPlayer = {\r\n    ...player,\r\n    inventory: newInventory,\r\n  };\r\n\r\n  const newPlayerList: PlayerListType = {\r\n    ...playerList,\r\n    [activePlayerNumber]: newPlayer,\r\n  };\r\n\r\n  return {\r\n    ...state,\r\n    doEffect: { type: \"!deleteCard\" },\r\n    playerList: newPlayerList,\r\n  };\r\n};\r\n\r\nconst getStateDeletedCard = (state: State): State => {\r\n  const { gameField, activePlayerNumber, playerList } = state;\r\n\r\n  const playerCoordIndex = playerList[activePlayerNumber].coord;\r\n\r\n  const currCell = gameField.values[playerCoordIndex];\r\n\r\n  const cellWithoutCard = deleteCard(currCell);\r\n\r\n  const newGameField: GameField = {\r\n    ...gameField,\r\n    values: {\r\n      ...gameField.values,\r\n      [playerCoordIndex]: cellWithoutCard,\r\n    },\r\n  };\r\n\r\n  const newPlayerNumber = getNextPlayerNumber(state);\r\n\r\n  return {\r\n    ...state,\r\n    gameField: newGameField,\r\n    gameState: { ...state.gameState, type: \"gameStarted.rollDice\" },\r\n    activePlayerNumber: newPlayerNumber,\r\n    dice: 0,\r\n  };\r\n};\r\n\r\nconst checkInventoryCardAppearance = (state: State): State => {\r\n  const { gameField, activePlayerNumber, playerList } = state;\r\n  const playerCoordIndex = playerList[activePlayerNumber].coord;\r\n  const currCell = gameField.values[playerCoordIndex];\r\n  //we now for sure there is card\r\n  const cardItemList = currCell.cardItem as CardItem[];\r\n  const isOneCardOnCell = cardItemList.length === 1;\r\n\r\n  switch (isOneCardOnCell) {\r\n    case true: {\r\n      const needOpenCard = cardItemList[0]?.appearance === \"closed\";\r\n\r\n      switch (needOpenCard) {\r\n        case true: {\r\n          return {\r\n            ...state,\r\n            doEffect: { type: \"!openCard\" },\r\n          };\r\n        }\r\n        case false: {\r\n          return { ...state, doEffect: { type: \"!takeCard\" } };\r\n        }\r\n\r\n        default: {\r\n          return state;\r\n        }\r\n      }\r\n    }\r\n    //If the previous player died\r\n    case false: {\r\n      return { ...state, doEffect: { type: \"!takeCard\" } };\r\n    }\r\n\r\n    default: {\r\n      return state;\r\n    }\r\n  }\r\n};\r\n","import { CellType, CardItem } from \"../../../types\";\r\n\r\nexport const openCard = (cell: CellType): CellType => {\r\n  if (cell.name === \"commonCell\" && cell.cardItem) {\r\n    /**\r\n     * When we open card we now for sure that in cell lying only one card\r\n     */\r\n    const cardItemWithOpenCard = cell.cardItem.map((cardItem) => {\r\n      /*  if (cardItem) { */\r\n      const openedCard: CardItem = {\r\n        ...cardItem,\r\n        appearance: \"open\",\r\n      };\r\n      return openedCard;\r\n      /* } else {\r\n        return null;\r\n      } */\r\n    });\r\n\r\n    const openedItem: CellType = {\r\n      ...cell,\r\n      cardItem: cardItemWithOpenCard,\r\n    };\r\n\r\n    return openedItem;\r\n  } else {\r\n    return cell;\r\n  }\r\n};\r\n","import { CommonCell, CellType } from \"../../../types\";\r\n\r\nexport const deleteCard = (currCell: CellType): CellType => {\r\n  /**\r\n   * When we delete card we now for sure that in cell lying only one card\r\n   */\r\n  if (currCell.name === \"commonCell\") {\r\n    const cellWithoutHealth: CommonCell = {\r\n      ...currCell,\r\n      cardItem: [],\r\n    };\r\n    return cellWithoutHealth;\r\n  } else return currCell;\r\n};\r\n","import { PlayerName, State } from \"../../../types\";\r\nimport { ActionType } from \"../../../reducer\";\r\n\r\nexport const rollDice = (state: State, action: ActionType): State => {\r\n  switch (action.type) {\r\n    case \"diceThrown\": {\r\n      const typeOfPlayer: PlayerName = state.playerList[\r\n        state.activePlayerNumber\r\n      ]\r\n        ? \"player\"\r\n        : \"dead\";\r\n\r\n      switch (typeOfPlayer) {\r\n        case \"dead\": {\r\n          return {\r\n            ...state,\r\n            dice: action.payload,\r\n            gameState: {\r\n              ...state.gameState,\r\n              type: \"enemyMove.chooseEnemy\",\r\n            },\r\n          };\r\n        }\r\n\r\n        case \"player\": {\r\n          return {\r\n            ...state,\r\n            dice: action.payload,\r\n            gameState: { ...state.gameState, type: \"gameStarted.playerMove\" },\r\n            doEffect: { type: \"!checkAvailableNeighboringCell\" },\r\n          };\r\n        }\r\n      }\r\n      break;\r\n    }\r\n\r\n    default:\r\n      return state;\r\n  }\r\n};\r\n","import { DeadPlayerListType, State } from \"../../types\";\r\nimport { getNextPlayerNumber } from \"../common/getNextPlayerNumber\";\r\n\r\nexport const getBattleResult = (state: State): State => {\r\n  const { dice } = state;\r\n\r\n  switch (dice) {\r\n    case 1:\r\n    case 2: {\r\n      return getStatePlayerCanFight(state) /* as State */;\r\n    }\r\n\r\n    case 3: {\r\n      return getStatePlayerLoseHealth(state);\r\n    }\r\n\r\n    case 4: {\r\n      return getStatePlayerRunsAway(state);\r\n    }\r\n    default:\r\n      return state;\r\n  }\r\n};\r\n\r\nconst getStatePlayerCanFight = (state: State): State => {\r\n  //Player can use weapon or rethrow dice\r\n  return {\r\n    ...state,\r\n    dice: 0,\r\n    gameState: {\r\n      ...state.gameState,\r\n      type: \"interactWithEnemy.makeBattleAction\",\r\n    },\r\n  };\r\n};\r\n\r\nconst getStatePlayerRunsAway = (state: State): State => {\r\n  return {\r\n    ...state,\r\n    dice: 0,\r\n    gameState: {\r\n      ...state.gameState,\r\n      type: \"gameStarted.rollDice\",\r\n    },\r\n  };\r\n};\r\n\r\nconst getStatePlayerLoseHealth = (state: State): State => {\r\n  const { playerList, activePlayerNumber, deadPlayerList, gameState } = state;\r\n  const newPlayerHealth = playerList[activePlayerNumber].health - 1;\r\n  const isPlayerAlive = newPlayerHealth > 0 ? true : false;\r\n\r\n  switch (isPlayerAlive) {\r\n    case true: {\r\n      const newPlayerList = {\r\n        ...playerList,\r\n        [activePlayerNumber]: {\r\n          ...playerList[activePlayerNumber],\r\n          health: playerList[activePlayerNumber].health - 1,\r\n        },\r\n      };\r\n\r\n      const newState: State = {\r\n        ...state,\r\n        dice: 0,\r\n        gameState: {\r\n          ...state.gameState,\r\n\r\n          type: \"interactWithEnemy.throwBattleDice\",\r\n        },\r\n        playerList: newPlayerList,\r\n      };\r\n\r\n      return newState;\r\n    }\r\n\r\n    case false: {\r\n      const newPlayerListObj = Object.entries(playerList).filter(\r\n        (playerList) => {\r\n          const [index] = playerList;\r\n          return Number(index) !== activePlayerNumber;\r\n        }\r\n      );\r\n      const newPlayerList = Object.fromEntries(newPlayerListObj);\r\n\r\n      const newDeadPlayerList: DeadPlayerListType = {\r\n        ...deadPlayerList,\r\n        [activePlayerNumber]: {\r\n          orderNumber: playerList[activePlayerNumber].orderNumber,\r\n          name: \"dead\",\r\n        },\r\n      };\r\n\r\n      const newPlayerNumber = getNextPlayerNumber(state);\r\n\r\n      const { attackInitiator, ...newGameState } = gameState;\r\n\r\n      const newState: State = {\r\n        ...state,\r\n        dice: 0,\r\n        gameState: {\r\n          ...newGameState,\r\n          type: \"gameStarted.rollDice\",\r\n        },\r\n\r\n        deadPlayerList: newDeadPlayerList,\r\n        playerList: newPlayerList,\r\n        activePlayerNumber: newPlayerNumber,\r\n      };\r\n\r\n      return newState;\r\n    }\r\n  }\r\n};\r\n","import { InventoryType, PlayerListType } from \"../../types\";\r\n\r\nexport const deleteSelectedCard = (\r\n  playerList: PlayerListType,\r\n  activePlayerNumber: number\r\n) => {\r\n  const currInventory = playerList[activePlayerNumber].inventory;\r\n\r\n  const removedCardType = playerList[activePlayerNumber].inventory.cardSelected;\r\n\r\n  if (removedCardType) {\r\n    const newInventory: InventoryType = {\r\n      ...currInventory,\r\n      [removedCardType]: currInventory[removedCardType] - 1,\r\n      cardSelected: null,\r\n    };\r\n\r\n    return newInventory;\r\n  } else {\r\n    return currInventory;\r\n  }\r\n};\r\n","import { State } from \"../../types\";\r\nimport { ActionType } from \"../../reducer\";\r\n\r\nexport const thrownBattleDice = (state: State, action: ActionType): State => {\r\n  switch (action.type) {\r\n    case \"diceThrown\": {\r\n      return {\r\n        ...state,\r\n        dice: action.payload,\r\n        gameState: { ...state.gameState, type: \"interactWithEnemy\" },\r\n        doEffect: { type: \"!getBattleResult\" },\r\n      };\r\n    }\r\n\r\n    default:\r\n      return state;\r\n  }\r\n};\r\n","import { State } from \"../../types\";\r\nimport { ActionType } from \"../../reducer\";\r\nimport { changeSelectedCard } from \"./changeSelectedCard\";\r\n\r\nexport const selectCard = (state: State, action: ActionType) => {\r\n  const { playerList, activePlayerNumber } = state;\r\n  switch (action.type) {\r\n    case \"cardChoosed\": {\r\n      //TODO: now in battle we can chose any card from inventory\r\n\r\n      const currPlayerInventory = playerList[activePlayerNumber].inventory;\r\n\r\n      const isChosenCardWeapon =\r\n        action.payload.type === \"weapon\" ? true : false;\r\n\r\n      const hasWeapon = currPlayerInventory.weapon !== 0 ? true : false;\r\n\r\n      const chosenWeapon = isChosenCardWeapon && hasWeapon;\r\n\r\n      switch (chosenWeapon) {\r\n        case true: {\r\n          const newPlayerList = changeSelectedCard(state, action.payload.type);\r\n\r\n          const hasAnyCardSelected = newPlayerList[activePlayerNumber].inventory\r\n            .cardSelected\r\n            ? true\r\n            : false;\r\n\r\n          // The difference between weaponCard and other card that weapon are used in the battle.\r\n          // Obviously we need other stateWithoutSelectedCard for weapon\r\n          const stateWithSelectedCard: State = {\r\n            ...state,\r\n            playerList: newPlayerList,\r\n            gameState: {\r\n              ...state.gameState,\r\n              type: \"interactWithEnemy.applyCard\",\r\n            },\r\n          };\r\n\r\n          const stateWithoutSelectedCard: State = {\r\n            ...state,\r\n            playerList: newPlayerList,\r\n            gameState: {\r\n              ...state.gameState,\r\n              type: \"interactWithEnemy.makeBattleAction\",\r\n            },\r\n          };\r\n\r\n          switch (hasAnyCardSelected) {\r\n            case true:\r\n              return stateWithSelectedCard;\r\n            case false:\r\n              return stateWithoutSelectedCard;\r\n          }\r\n          break;\r\n        }\r\n        case false: {\r\n          return state;\r\n        }\r\n      }\r\n      break;\r\n    }\r\n\r\n    default: {\r\n      return state;\r\n    }\r\n  }\r\n};\r\n","import { State, PlayerListType, TypeOfInventoryCard } from \"../../types\";\r\n\r\nexport const changeSelectedCard = (\r\n  state: State,\r\n  typeOfSelect: TypeOfInventoryCard\r\n) => {\r\n  const { playerList, activePlayerNumber } = state;\r\n  const inventory = playerList[activePlayerNumber].inventory;\r\n\r\n  const currentTypeOfSelect =\r\n    playerList[activePlayerNumber].inventory.cardSelected;\r\n\r\n  const isTheSameSelectType = currentTypeOfSelect === typeOfSelect;\r\n\r\n  const newSelectType = isTheSameSelectType ? null : typeOfSelect;\r\n\r\n  const newInventory = { ...inventory, cardSelected: newSelectType };\r\n\r\n  const newPlayerList: PlayerListType = {\r\n    ...playerList,\r\n    [activePlayerNumber]: {\r\n      ...playerList[activePlayerNumber],\r\n      inventory: newInventory,\r\n    },\r\n  };\r\n\r\n  return newPlayerList;\r\n};\r\n","import { State } from \"../../types\";\r\n\r\nimport { ActionType } from \"../../reducer\";\r\nimport { openEnemyCard } from \"./openEnemyCard\";\r\nimport { getBattleResult } from \"./getBattleResult\";\r\nimport { removeEnemyCard } from \"./removeEnemyCard\";\r\nimport { getStateClickedEnemy } from \"./getStateClickedEnemy\";\r\nimport { checkCardAppearance } from \"./checkCardAppearance\";\r\nimport { thrownBattleDice } from \"./thrownBattleDice\";\r\nimport { selectCard } from \"./selectCard\";\r\n\r\nexport const interactWithEnemy = (state: State, action: ActionType): State => {\r\n  const [, phaseInner] = state.gameState.type.split(\".\");\r\n\r\n  switch (phaseInner) {\r\n    case \"makeBattleAction\": {\r\n      switch (action.type) {\r\n        case \"diceThrown\": {\r\n          return thrownBattleDice(state, action);\r\n        }\r\n\r\n        case \"cardChoosed\": {\r\n          return selectCard(state, action);\r\n        }\r\n\r\n        default: {\r\n          return state;\r\n        }\r\n      }\r\n    }\r\n\r\n    case \"applyCard\": {\r\n      switch (action.type) {\r\n        case \"cardChoosed\": {\r\n          return selectCard(state, action);\r\n        }\r\n\r\n        case \"clickedEnemy\": {\r\n          return getStateClickedEnemy(state, action);\r\n        }\r\n        case \"req-removeEnemyCard\": {\r\n          return removeEnemyCard(state);\r\n        }\r\n\r\n        default: {\r\n          return state;\r\n        }\r\n      }\r\n    }\r\n\r\n    case \"throwBattleDice\": {\r\n      return thrownBattleDice(state, action);\r\n    }\r\n\r\n    default: {\r\n      switch (action.type) {\r\n        case \"req-checkEnemyCard\": {\r\n          return checkCardAppearance(state);\r\n        }\r\n        case \"req-openCard\": {\r\n          return openEnemyCard(state);\r\n        }\r\n\r\n        // case \"req-openEnemyCard\": {\r\n        //   return openEnemyCard(state);\r\n        // }\r\n\r\n        case \"req-getBattleResult\": {\r\n          return getBattleResult(state);\r\n        }\r\n\r\n        default: {\r\n          return state;\r\n        }\r\n      }\r\n    }\r\n  }\r\n};\r\n","import { ActionType } from \"../../reducer\";\r\nimport { State, EnemyCardType } from \"../../types\";\r\nimport { deleteSelectedCard } from \"../common/deleteSelectedCard\";\r\n\r\nexport const getStateClickedEnemy = (\r\n  state: State,\r\n  action: ActionType\r\n): State => {\r\n  switch (action.type) {\r\n    case \"clickedEnemy\": {\r\n      const { activePlayerNumber, playerList, enemyList } = state;\r\n      const currEnemy = action.payload.enemyCard;\r\n      const currEnemyCoord = playerList[activePlayerNumber].coord;\r\n\r\n      const playerCanFight =\r\n        playerList[activePlayerNumber].coord === currEnemyCoord;\r\n\r\n      const currEnemyIndex = Object.keys(enemyList).find((key) => {\r\n        return enemyList[Number(key)].coord === currEnemyCoord;\r\n      });\r\n\r\n      const defeatedEnemy: EnemyCardType = {\r\n        ...currEnemy,\r\n        feature: \"defeated\",\r\n      };\r\n\r\n      const newEnemyList = {\r\n        ...state.enemyList,\r\n        [Number(currEnemyIndex)]: defeatedEnemy,\r\n      };\r\n\r\n      const newInventory = deleteSelectedCard(playerList, activePlayerNumber);\r\n\r\n      const newPlayerList = {\r\n        ...playerList,\r\n        [activePlayerNumber]: {\r\n          ...playerList[activePlayerNumber],\r\n          inventory: newInventory,\r\n        },\r\n      };\r\n\r\n      switch (playerCanFight) {\r\n        case true: {\r\n          return {\r\n            ...state,\r\n            enemyList: newEnemyList,\r\n            playerList: newPlayerList,\r\n            doEffect: { type: \"!removeEnemyCard\" },\r\n          };\r\n        }\r\n        case false: {\r\n          return state;\r\n        }\r\n      }\r\n      break;\r\n    }\r\n    default: {\r\n      return state;\r\n    }\r\n  }\r\n};\r\n","import { EnemyListType, State } from \"../../types\";\r\nimport { getNextPlayerNumber } from \"../common/getNextPlayerNumber\";\r\n\r\nexport const removeEnemyCard = (state: State): State => {\r\n  const { enemyList, activePlayerNumber, playerList, gameState, gameField } =\r\n    state;\r\n\r\n  const currentCoord = playerList[activePlayerNumber].coord;\r\n\r\n  const newEnemyArray = Object.entries(enemyList).filter((enemyItem) => {\r\n    const [, enemyCard] = enemyItem;\r\n    return enemyCard.coord !== currentCoord;\r\n  });\r\n  const newEnemyList: EnemyListType = Object.fromEntries(newEnemyArray);\r\n\r\n  const newPlayerNumber = getNextPlayerNumber(state);\r\n\r\n  const { attackInitiator, ...newGameState } = gameState;\r\n\r\n  const cellHasCard = Boolean(gameField.values[currentCoord].cardItem?.length);\r\n\r\n  switch (cellHasCard) {\r\n    case true: {\r\n      return {\r\n        ...state,\r\n        enemyList: newEnemyList,\r\n        dice: 0,\r\n        gameState: {\r\n          ...newGameState,\r\n          type: \"gameStarted.takeCard\",\r\n        },\r\n        doEffect: { type: \"!checkAppearanceInventoryCard\" },\r\n      };\r\n    }\r\n\r\n    case false: {\r\n      return {\r\n        ...state,\r\n        enemyList: newEnemyList,\r\n        dice: 0,\r\n        gameState: {\r\n          ...newGameState,\r\n          type: \"gameStarted.rollDice\",\r\n        },\r\n        activePlayerNumber: newPlayerNumber,\r\n      };\r\n    }\r\n  }\r\n};\r\n","import { State } from \"../../types\";\r\n\r\nexport const checkCardAppearance = (state: State): State => {\r\n  const { enemyList, playerList, activePlayerNumber } = state;\r\n  const currentCoord = playerList[activePlayerNumber].coord;\r\n\r\n  const currEnemy = Object.entries(enemyList)\r\n    .map((enemyItem) => {\r\n      const [, enemyCard] = enemyItem;\r\n      return enemyCard;\r\n    })\r\n    .find((enemyCard) => {\r\n      return enemyCard.coord === currentCoord;\r\n    });\r\n\r\n  const isNeedOpenEnemyCard = currEnemy?.appearance === \"open\" ? false : true;\r\n\r\n  switch (true) {\r\n    case isNeedOpenEnemyCard: {\r\n      return {\r\n        ...state,\r\n        doEffect: { type: \"!openCard\" },\r\n        /*  doEffect: { type: \"!openEnemyCard\" }, */\r\n      };\r\n    }\r\n\r\n    case !isNeedOpenEnemyCard: {\r\n      return {\r\n        ...state,\r\n        gameState: {\r\n          ...state.gameState,\r\n          type: \"interactWithEnemy.throwBattleDice\",\r\n        },\r\n\r\n        dice: 0,\r\n      };\r\n    }\r\n\r\n    default: {\r\n      return state;\r\n    }\r\n  }\r\n};\r\n","import { EnemyListType, State } from \"../../types\";\r\n\r\n/**\r\n * Need separate method for open EnemyCard\r\n * Because it does not structurally lie on the cell\r\n */\r\nexport const openEnemyCard = (state: State): State => {\r\n  const { enemyList, playerList, activePlayerNumber } = state;\r\n  const currentCoord = playerList[activePlayerNumber].coord;\r\n\r\n  //TODO: we have one enemy in the same coordinate, but if not?\r\n  //TODO:  took out common functional for coordinates\r\n  const currEnemyIndex = Object.entries(enemyList)\r\n    .filter(([, enemyCard]) => {\r\n      return enemyCard.coord === currentCoord;\r\n    })\r\n    .map(([index]) => {\r\n      return index;\r\n    })\r\n    .join();\r\n\r\n  const newEnemyList: EnemyListType = {\r\n    ...enemyList,\r\n    [currEnemyIndex]: {\r\n      ...enemyList[Number(currEnemyIndex)],\r\n      appearance: \"open\",\r\n    },\r\n  };\r\n\r\n  if (currEnemyIndex) {\r\n    return {\r\n      ...state,\r\n      enemyList: newEnemyList,\r\n      gameState: {\r\n        ...state.gameState,\r\n        type: \"interactWithEnemy.throwBattleDice\",\r\n      },\r\n      dice: 0,\r\n    };\r\n  } else {\r\n    return state;\r\n  }\r\n};\r\n","import { State } from \"../../../types\";\r\n\r\nexport const getStateGiveCard = (\r\n  state: State,\r\n  recipientPlayerNumber: number\r\n): State => {\r\n  const { playerList, activePlayerNumber } = state;\r\n  const indexCurrPlayer = activePlayerNumber;\r\n\r\n  const currentPlayerInventory = playerList[indexCurrPlayer].inventory;\r\n  const recepientPlayerInventory = playerList[recipientPlayerNumber].inventory;\r\n\r\n  const sharedCardType = playerList[indexCurrPlayer].inventory.cardSelected;\r\n\r\n  if (sharedCardType) {\r\n    const newCurrentPlayerInventory = {\r\n      ...currentPlayerInventory,\r\n      [sharedCardType]: currentPlayerInventory[sharedCardType] - 1,\r\n      cardSelected: null,\r\n    };\r\n\r\n    const newRecepientPlayerInventory = {\r\n      ...recepientPlayerInventory,\r\n      [sharedCardType]: recepientPlayerInventory[sharedCardType] + 1,\r\n    };\r\n\r\n    const newPlayerList = {\r\n      ...playerList,\r\n      [indexCurrPlayer]: {\r\n        ...playerList[indexCurrPlayer],\r\n        inventory: newCurrentPlayerInventory,\r\n      },\r\n      [recipientPlayerNumber]: {\r\n        ...playerList[recipientPlayerNumber],\r\n        inventory: newRecepientPlayerInventory,\r\n      },\r\n    };\r\n\r\n    return {\r\n      ...state,\r\n      playerList: newPlayerList,\r\n      gameState: { ...state.gameState, type: \"gameStarted.playerMove\" },\r\n      doEffect: { type: \"!checkAvailableNeighboringCell\" },\r\n    };\r\n  } else {\r\n    return state;\r\n  }\r\n};\r\n","import { PlayerListType } from \"../../../types\";\r\n\r\nexport const changeHealth = (\r\n  playerList: PlayerListType,\r\n  indexTarget: number\r\n) => {\r\n  return playerList[indexTarget].health + 1;\r\n};\r\n","import { State, ContextMenuButtonType } from \"../../../types\";\r\nimport { getStateGiveCard } from \"./getStateGiveCard\";\r\nimport { getStateHealAnotherPlayer } from \"./getStateHealAnotherPlayer\";\r\n\r\nexport const getStateClickedContextMenu = (\r\n  state: State,\r\n  recipientPlayerNumber: number,\r\n  typeOfAction: ContextMenuButtonType\r\n): State => {\r\n  switch (typeOfAction) {\r\n    case \"heal\": {\r\n      const newState = getStateHealAnotherPlayer(state, recipientPlayerNumber);\r\n      const stateClosedContextMenu = closeContextMenu(\r\n        newState,\r\n        recipientPlayerNumber\r\n      );\r\n      return stateClosedContextMenu;\r\n    }\r\n\r\n    case \"share\": {\r\n      const newState = getStateGiveCard(state, recipientPlayerNumber);\r\n      const stateClosedContextMenu = closeContextMenu(\r\n        newState,\r\n        recipientPlayerNumber\r\n      );\r\n      return stateClosedContextMenu;\r\n    }\r\n\r\n    default: {\r\n      return state;\r\n    }\r\n  }\r\n};\r\n\r\nconst closeContextMenu = (state: State, recipientPlayerNumber: number) => {\r\n  const stateClosedContextMenu = {\r\n    ...state,\r\n    playerList: {\r\n      ...state.playerList,\r\n      [recipientPlayerNumber]: {\r\n        ...state.playerList[recipientPlayerNumber],\r\n        showContextMenu: false,\r\n      },\r\n    },\r\n  };\r\n  return stateClosedContextMenu;\r\n};\r\n","import { State, PlayerListType } from \"../../../types\";\r\n\r\nimport { deleteSelectedCard } from \"../../common/deleteSelectedCard\";\r\nimport { changeHealth } from \"./changeHealth\";\r\n\r\nexport const getStateHealAnotherPlayer = (\r\n  state: State,\r\n  indexChosenPlayer: number\r\n): State => {\r\n  const { playerList, activePlayerNumber } = state;\r\n  const indexCurrPlayer = activePlayerNumber;\r\n  const newInventory = deleteSelectedCard(playerList, activePlayerNumber);\r\n  const newHealth = changeHealth(playerList, indexChosenPlayer);\r\n\r\n  const newPlayerList: PlayerListType = {\r\n    ...playerList,\r\n    [indexChosenPlayer]: {\r\n      ...playerList[indexChosenPlayer],\r\n      health: newHealth,\r\n    },\r\n    [indexCurrPlayer]: {\r\n      ...playerList[indexCurrPlayer],\r\n      inventory: newInventory,\r\n    },\r\n  };\r\n\r\n  return {\r\n    ...state,\r\n    playerList: newPlayerList,\r\n    gameState: { ...state.gameState, type: \"gameStarted.playerMove\" },\r\n    doEffect: {\r\n      type: \"!checkAvailableNeighboringCell\",\r\n    },\r\n  };\r\n};\r\n","import { State, MoveDirection } from \"../../types\";\r\nimport { checkCellHasWall } from \".\";\r\n\r\n/** Cheking the cases when can't take the cell. In default we think that can. */\r\nexport const canInteractWithCell = (\r\n  state: State,\r\n  nextPlayerCoord: string,\r\n  direction: MoveDirection\r\n) => {\r\n  const { gameField } = state;\r\n  const nextCellForPlayer = gameField.values[nextPlayerCoord];\r\n  const nextCellOutOfGameField = nextCellForPlayer ? false : true;\r\n\r\n  switch (nextCellOutOfGameField) {\r\n    case true: {\r\n      return false;\r\n    }\r\n\r\n    case false: {\r\n      const metBarrier = checkCellHasWall(state, nextPlayerCoord, direction);\r\n\r\n      switch (true) {\r\n        case metBarrier: {\r\n          return false;\r\n        }\r\n\r\n        default: {\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n    default: {\r\n      return true;\r\n    }\r\n  }\r\n};\r\n","import { canInteractWithCell } from \"../../common/canInteractWithCell\";\r\nimport { State, PLayerType, AvailableCellListType } from \"../../../types\";\r\nimport { getNeighboringCellList } from \"../../common\";\r\nimport { getStateGiveCard } from \"./getStateGiveCard\";\r\nimport { getStateHealCurrPlayer } from \"./getStateHealCurrPlayer\";\r\n\r\nexport const getStateClickedPlayer = (\r\n  state: State,\r\n  clickedPlayerCard: PLayerType\r\n) => {\r\n  const { activePlayerNumber, playerList } = state;\r\n\r\n  const currPlayer = playerList[activePlayerNumber];\r\n  const isCurrentPlayer = clickedPlayerCard.orderNumber === activePlayerNumber;\r\n  const cellsForInteract = getCellsForInteract(state);\r\n  const listForHealing = cellsForInteract.concat(currPlayer.coord);\r\n  const canInteractWithPlayer = listForHealing.includes(\r\n    clickedPlayerCard.coord\r\n  );\r\n\r\n  const typeOfChosedCard =\r\n    playerList[activePlayerNumber].inventory.cardSelected;\r\n\r\n  switch (canInteractWithPlayer) {\r\n    case true: {\r\n      switch (typeOfChosedCard) {\r\n        case \"health\": {\r\n          switch (isCurrentPlayer) {\r\n            case true: {\r\n              return getStateHealCurrPlayer(state);\r\n            }\r\n\r\n            case false: {\r\n              const clickedPlayerCardNumber = clickedPlayerCard.orderNumber;\r\n              return openContextMenu(state, clickedPlayerCardNumber);\r\n            }\r\n\r\n            default: {\r\n              return state;\r\n            }\r\n          }\r\n        }\r\n\r\n        case \"weapon\":\r\n        case \"boards\": {\r\n          /**\r\n           * For preventing sharing any cards with himself\r\n           */\r\n          switch (isCurrentPlayer) {\r\n            case true: {\r\n              return state;\r\n            }\r\n\r\n            case false: {\r\n              return getStateGiveCard(state, clickedPlayerCard.orderNumber);\r\n            }\r\n\r\n            default: {\r\n              return state;\r\n            }\r\n          }\r\n        }\r\n\r\n        default: {\r\n          return state;\r\n        }\r\n      }\r\n    }\r\n\r\n    case false: {\r\n      console.log(\"не можем взаимодействовать с игроком \");\r\n      return state;\r\n    }\r\n\r\n    default: {\r\n      return state;\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Open context menu at recipient  card\r\n */\r\nconst openContextMenu = (state: State, recipientPlayerNumber: number) => {\r\n  const stateOpenedContextMenu: State = {\r\n    ...state,\r\n    playerList: {\r\n      ...state.playerList,\r\n      [recipientPlayerNumber]: {\r\n        ...state.playerList[recipientPlayerNumber],\r\n        showContextMenu: true,\r\n      },\r\n    },\r\n  };\r\n\r\n  return stateOpenedContextMenu;\r\n};\r\n\r\n/**\r\n * Show coordinates of cells with wich player can interact(apply card)\r\n */\r\nconst getCellsForInteract = (state: State) => {\r\n  const { gameState, playerList, activePlayerNumber, gameField } = state;\r\n  const prevPlayerCoord = playerList[activePlayerNumber].coord;\r\n\r\n  const neighboringCellList = getNeighboringCellList(\r\n    prevPlayerCoord,\r\n    gameField\r\n  );\r\n\r\n  const availableCellList: AvailableCellListType = neighboringCellList.filter(\r\n    (cellItem) => {\r\n      const { direction, coord } = cellItem;\r\n\r\n      return canInteractWithCell(state, coord, direction);\r\n    }\r\n  );\r\n\r\n  const availableCellsCoords = availableCellList.map((cellItem) => {\r\n    const { coord } = cellItem;\r\n    return coord;\r\n  });\r\n\r\n  switch (gameState.type) {\r\n    case \"gameStarted.applyCard\":\r\n      return availableCellsCoords;\r\n\r\n    default:\r\n      return [];\r\n  }\r\n};\r\n","import { State, PlayerListType } from \"../../../types\";\r\n\r\nimport { deleteSelectedCard } from \"../../common/deleteSelectedCard\";\r\nimport { changeHealth } from \"./changeHealth\";\r\n\r\nexport const getStateHealCurrPlayer = (state: State): State => {\r\n  const { playerList, activePlayerNumber } = state;\r\n  const indexCurrPlayer = activePlayerNumber;\r\n  const newHealth = changeHealth(playerList, indexCurrPlayer);\r\n  const newInventory = deleteSelectedCard(playerList, activePlayerNumber);\r\n  const newPlayerList: PlayerListType = {\r\n    ...playerList,\r\n    [indexCurrPlayer]: {\r\n      ...playerList[indexCurrPlayer],\r\n      inventory: newInventory,\r\n      health: newHealth,\r\n    },\r\n  };\r\n\r\n  return {\r\n    ...state,\r\n    playerList: newPlayerList,\r\n    gameState: { ...state.gameState, type: \"gameStarted.playerMove\" },\r\n    doEffect: {\r\n      type: \"!checkAvailableNeighboringCell\",\r\n    },\r\n  };\r\n};\r\n","import { State } from \"../../../types\";\r\nimport { ActionType } from \"../../../reducer\";\r\n\r\nimport { getStateCardSelected } from \"../../common/getStateCardSelected\";\r\nimport { getStateHoleFilled } from \"./getStateHoleFilled\";\r\nimport { getStateClickedContextMenu } from \"./getStateClickedContextMenu\";\r\nimport { getStateClickedPlayer } from \"./getStateClickedPlayer\";\r\nimport { getAvailableCards } from \"./getAvailableCards\";\r\n/**\r\n *  In payload get order number of chosen for interact player.\r\n * If this number = indexCurrPlayer we heal player.\r\n * If not - we give context menu: need heal or apply.\r\n */\r\nexport const applyCard = (state: State, action: ActionType): State => {\r\n  switch (action.type) {\r\n    case \"cardChoosed\": {\r\n      const typeOfSelect = action.payload.type;\r\n      return getStateCardSelected(state, typeOfSelect);\r\n    }\r\n\r\n    case \"req-fillHole\": {\r\n      const { coord, direction } = action.payload;\r\n      return getStateHoleFilled(state, coord, direction);\r\n    }\r\n\r\n    case \"clickedContextMenu\": {\r\n      const recipientPlayerNumber = action.payload.card.orderNumber;\r\n      const typeOfAction = action.payload.buttonType;\r\n      return getStateClickedContextMenu(\r\n        state,\r\n        recipientPlayerNumber,\r\n        typeOfAction\r\n      );\r\n    }\r\n\r\n    case \"clickedPlayer\": {\r\n      const clickedPlayerCard = action.payload;\r\n      return getStateClickedPlayer(state, clickedPlayerCard);\r\n    }\r\n\r\n    case \"req-checkAvailableNeighboringCards\": {\r\n      const coordOfAvailableCards = getAvailableCards(state);\r\n      return {\r\n        ...state,\r\n        gameState: { ...state.gameState, coordOfAvailableCards },\r\n      };\r\n    }\r\n\r\n    default: {\r\n      return state;\r\n    }\r\n  }\r\n};\r\n","import { State, PlayerListType, MoveDirection } from \"../../../types\";\r\n\r\nimport { deleteSelectedCard } from \"../../common/deleteSelectedCard\";\r\n\r\nexport const getStateHoleFilled = (\r\n  state: State,\r\n  coord: number,\r\n  direction: MoveDirection\r\n) => {\r\n  const { gameField, playerList, activePlayerNumber } = state;\r\n  const indexCurrPlayer = activePlayerNumber;\r\n  const newInventory = deleteSelectedCard(playerList, activePlayerNumber);\r\n  const cellWithChosedHole = gameField.values[coord];\r\n\r\n  if (cellWithChosedHole.name === \"commonCell\") {\r\n    const barriersWithClosedHole = cellWithChosedHole.barrierList?.map(\r\n      (barrier) => {\r\n        if (barrier.direction === direction) {\r\n          return { ...barrier, isOpen: false };\r\n        } else return barrier;\r\n      }\r\n    );\r\n\r\n    const newGameField = {\r\n      ...gameField,\r\n      values: {\r\n        ...gameField.values,\r\n        [coord]: {\r\n          ...gameField.values[coord],\r\n          barrierList: barriersWithClosedHole,\r\n        },\r\n      },\r\n    };\r\n\r\n    const newPlayerList: PlayerListType = {\r\n      ...playerList,\r\n      [indexCurrPlayer]: {\r\n        ...playerList[indexCurrPlayer],\r\n        inventory: newInventory,\r\n      },\r\n    };\r\n\r\n    const newState: State = {\r\n      ...state,\r\n      gameField: newGameField,\r\n      playerList: newPlayerList,\r\n      gameState: { ...state.gameState, type: \"gameStarted.playerMove\" },\r\n      doEffect: { type: \"!checkAvailableNeighboringCell\" },\r\n    };\r\n\r\n    return newState;\r\n  } else {\r\n    return state;\r\n  }\r\n};\r\n","import { canInteractWithCell } from \"../../common/canInteractWithCell\";\r\nimport { AvailableCellListType, State } from \"../../../types\";\r\nimport { getNeighboringCellList } from \"../../common\";\r\n\r\nexport const getAvailableCards = (state: State) => {\r\n  const { playerList, activePlayerNumber, gameField } = state;\r\n\r\n  const activePlayerCoord = playerList[activePlayerNumber].coord;\r\n\r\n  const neighboringCellList = getNeighboringCellList(\r\n    activePlayerCoord,\r\n    gameField\r\n  );\r\n\r\n  const availableCellList: AvailableCellListType = neighboringCellList.filter(\r\n    (cellItem) => {\r\n      const { direction, coord } = cellItem;\r\n\r\n      return canInteractWithCell(state, coord, direction);\r\n    }\r\n  );\r\n\r\n  const availableCellsCoords = availableCellList\r\n    .map((cellItem) => {\r\n      const { coord } = cellItem;\r\n      return coord;\r\n    })\r\n    .concat(activePlayerCoord);\r\n\r\n  return availableCellsCoords;\r\n};\r\n","import { State } from \"../../types\";\r\nimport { ActionType } from \"../../reducer\";\r\n\r\nexport const endGame = (state: State, action: ActionType): State => {\r\n  switch (action.type) {\r\n    case \"req-getEndScreen\": {\r\n      return {\r\n        ...state,\r\n        gameState: { ...state.gameState, type: \"getEndScreen\" },\r\n      };\r\n    }\r\n\r\n    default:\r\n      return state;\r\n  }\r\n};\r\n","import { State } from \"../../../types\";\r\nimport { ActionType } from \"../../../reducer\";\r\n\r\nexport const getPlayersOrder = (state: State, action: ActionType): State => {\r\n  const numberCurrPlayer = state.activePlayerNumber;\r\n  const commonPlayerList = { ...state.playerList, ...state.deadPlayerList };\r\n  const playerList = Object.entries(commonPlayerList);\r\n  const maxPlayersNumber = playerList.length - 1;\r\n  const minPlayersNumber = 0;\r\n  const nextPlayersNumber =\r\n    numberCurrPlayer + 1 > maxPlayersNumber\r\n      ? minPlayersNumber\r\n      : numberCurrPlayer + 1;\r\n\r\n  switch (action.type) {\r\n    case \"req-getNextPlayer\": {\r\n      return {\r\n        ...state,\r\n        activePlayerNumber: nextPlayersNumber,\r\n        gameState: { ...state.gameState, type: \"gameStarted.rollDice\" },\r\n      };\r\n    }\r\n\r\n    default:\r\n      return state;\r\n  }\r\n};\r\n","import { State, MoveDirection, EnemyListType } from \"../../types\";\r\n\r\nimport { checkCellHasWall } from \"../common/checkCellHasWall\";\r\n/*\r\n * Cheking the cases when can't take the cell. In default we think that can.\r\n */\r\nexport const checkCanTakeCell = (\r\n  state: State,\r\n  nextPlayerCoord: string,\r\n  direction: MoveDirection\r\n) => {\r\n  const { dice, enemyList } = state;\r\n  const metBarrier = checkCellHasWall(state, nextPlayerCoord, direction);\r\n  const isLastStepOfMove = dice === 1;\r\n  const isNextCellOcupied = checkNextCellOccupied(enemyList, nextPlayerCoord);\r\n  const canNotTakeCell = isLastStepOfMove && isNextCellOcupied;\r\n\r\n  switch (true) {\r\n    case metBarrier: {\r\n      return false;\r\n    }\r\n\r\n    case canNotTakeCell: {\r\n      // TODO: можно сделать промежуточное состояние для статуса с предупреждением о занятой чейке\r\n      return false;\r\n    }\r\n    default: {\r\n      return true;\r\n    }\r\n  }\r\n};\r\n\r\nconst checkNextCellOccupied = (\r\n  enemyList: EnemyListType,\r\n  newCoord: string\r\n): boolean => {\r\n  const iterableEnemyList = Object.entries(enemyList);\r\n  const isCellOccupied = iterableEnemyList.some(([, enemyCard]) => {\r\n    return enemyCard.coord === newCoord && enemyCard.appearance !== \"closed\";\r\n  });\r\n  return isCellOccupied;\r\n};\r\n","import { AvailableCellListType, State } from \"../../types\";\r\nimport { getNeighboringCellList } from \"../common\";\r\nimport { checkCanTakeCell } from \"./checkCanTakeCell\";\r\n\r\n/**\r\n * Current player(deadPlayer) get field \"availableForTake\" with coordinate of cells that can be taken\r\n */\r\n\r\nexport const getAvailableCells = (state: State): State => {\r\n  const { activePlayerNumber, gameField, deadPlayerList, enemyList } = state;\r\n\r\n  const enemyIndex =\r\n    deadPlayerList && deadPlayerList[activePlayerNumber].index\r\n      ? deadPlayerList[activePlayerNumber].index\r\n      : null;\r\n\r\n  const deadPLayerCoord = enemyIndex ? enemyList[enemyIndex].coord : null;\r\n\r\n  if (deadPLayerCoord) {\r\n    const neighboringCellList = getNeighboringCellList(\r\n      deadPLayerCoord,\r\n      gameField\r\n    );\r\n\r\n    /**\r\n     * Returns the coordinates of cell that can be taken by deadPlayer.\r\n     */\r\n    const availableCellList: AvailableCellListType = neighboringCellList.filter(\r\n      (cellItem) => {\r\n        const { direction, coord } = cellItem;\r\n\r\n        return checkCanTakeCell(state, coord, direction);\r\n      }\r\n    );\r\n\r\n    const coordOfAvailableCells = availableCellList.map((cellItem) => {\r\n      const { coord } = cellItem;\r\n      return coord;\r\n    });\r\n\r\n    return {\r\n      ...state,\r\n      doEffect: null,\r\n      gameState: { ...state.gameState, coordOfAvailableCells },\r\n    };\r\n  } else {\r\n    return state;\r\n  }\r\n};\r\n","import { DeadPlayerListType, State } from \"../../types\";\r\nimport { getNextPlayerNumber } from \"../common/getNextPlayerNumber\";\r\n\r\nexport const getStateSwitchPlayer = (state: State) => {\r\n  const { deadPlayerList } = state;\r\n\r\n  if (deadPlayerList) {\r\n    const newPlayerNumber = getNextPlayerNumber(state);\r\n\r\n    const newDeadPlayerList: DeadPlayerListType = Object.fromEntries(\r\n      Object.entries(deadPlayerList).map(([orderIndex, deadPlayerItem]) => {\r\n        const { name, orderNumber } = deadPlayerItem;\r\n        return [orderIndex, { name, orderNumber }];\r\n      })\r\n    );\r\n\r\n    const newState: State = {\r\n      ...state,\r\n      dice: 0,\r\n      gameState: { ...state.gameState, type: \"gameStarted.rollDice\" },\r\n      activePlayerNumber: newPlayerNumber,\r\n      deadPlayerList: newDeadPlayerList,\r\n    };\r\n    return newState;\r\n  } else {\r\n    return state;\r\n  }\r\n};\r\n","import { State } from \"../../types\";\r\n\r\nimport { ActionType } from \"../../reducer\";\r\n\r\nimport { getAvailableCells } from \"./getAvailableCells\";\r\nimport { getStateEnemySelected } from \"./getStateEnemySelected\";\r\nimport { getStateEnemyMoved } from \"./getStateEnemyMoved\";\r\nimport { getEnemyMoveResult } from \"./getEnemyMoveResult\";\r\nimport { getStateSwitchPlayer } from \"./getStateSwitchPlayer\";\r\nimport { getStatePlayerMovedToCoord } from \"../gameStarted/playerMove/getStatePlayerMovedToCoord\";\r\nimport { getStateEnemyMovedToCoord } from \"./getStateEnemyMovedToCoord\";\r\n\r\nexport const enemyMove = (state: State, action: ActionType): State => {\r\n  const [, phaseInner] = state.gameState.type.split(\".\");\r\n\r\n  switch (phaseInner) {\r\n    case \"chooseEnemy\": {\r\n      switch (action.type) {\r\n        case \"clickedEnemy\": {\r\n          return getStateEnemySelected(state, action);\r\n        }\r\n\r\n        case \"clickedSkip\": {\r\n          return getStateSwitchPlayer(state);\r\n        }\r\n\r\n        default: {\r\n          return state;\r\n        }\r\n      }\r\n    }\r\n\r\n    default: {\r\n      switch (action.type) {\r\n        case \"req-checkAvailableNeighboringCell\": {\r\n          return getAvailableCells(state);\r\n        }\r\n\r\n        case \"playerWasMoved\": {\r\n          const newCoord = action.payload;\r\n          return getStateEnemyMovedToCoord(state, newCoord);\r\n        }\r\n\r\n        case \"moveControlsClicked\": {\r\n          return getStateEnemyMoved(state, action);\r\n        }\r\n\r\n        case \"req-getPlayerMoveResult\": {\r\n          return getEnemyMoveResult(state);\r\n        }\r\n\r\n        case \"req-switchToNextPlayer\": {\r\n          return getStateSwitchPlayer(state);\r\n        }\r\n\r\n        default: {\r\n          return state;\r\n        }\r\n      }\r\n    }\r\n  }\r\n};\r\n","import { ActionType } from \"../../reducer\";\r\nimport { State } from \"../../types\";\r\n\r\nexport const getStateEnemySelected = (\r\n  state: State,\r\n  action: ActionType\r\n): State => {\r\n  switch (action.type) {\r\n    case \"clickedEnemy\": {\r\n      const { enemyList, deadPlayerList, activePlayerNumber } = state;\r\n      const currEnemyCard = action.payload.enemyCard;\r\n\r\n      /**\r\n       * we should compare indexes. They doesnt change!!!\r\n       */\r\n      const currEnemyIndex = Object.keys(enemyList).find((key) => {\r\n        return (\r\n          enemyList[Number(key)].coord === currEnemyCard.coord &&\r\n          enemyList[Number(key)].appearance === \"open\"\r\n        );\r\n      });\r\n\r\n      if (deadPlayerList) {\r\n        /**\r\n         * Choose enemy once!\r\n         */\r\n        const hasEnemyCard = deadPlayerList[activePlayerNumber]?.index\r\n          ? false\r\n          : true;\r\n\r\n        const isOpenEnemyCard =\r\n          enemyList[Number(currEnemyIndex)].appearance === \"open\";\r\n\r\n        const canPickEnemyCard = hasEnemyCard && isOpenEnemyCard;\r\n\r\n        switch (canPickEnemyCard) {\r\n          case false: {\r\n            return state;\r\n          }\r\n          case true: {\r\n            const newDeadPLayerList = {\r\n              ...deadPlayerList,\r\n              [activePlayerNumber]: {\r\n                ...deadPlayerList[activePlayerNumber],\r\n                index: currEnemyIndex,\r\n              },\r\n            };\r\n\r\n            return {\r\n              ...state,\r\n              gameState: {\r\n                ...state.gameState,\r\n                type: \"enemyMove\",\r\n              },\r\n              doEffect: { type: \"!checkAvailableNeighboringCell\" },\r\n              deadPlayerList: newDeadPLayerList,\r\n            };\r\n          }\r\n        }\r\n      } else {\r\n        return state;\r\n      }\r\n      break;\r\n    }\r\n\r\n    default: {\r\n      return state;\r\n    }\r\n  }\r\n};\r\n","import { CoordItem, EnemyListType, State } from \"../../types\";\r\nimport { getNextPlayerCoord } from \"../common\";\r\n\r\n/**\r\n * Changing coordinates of player if he can take the cell in certain direction.\r\n */\r\nexport const getStateEnemyMovedToCoord = (\r\n  state: State,\r\n  newCoord: CoordItem\r\n): State => {\r\n  const { deadPlayerList, activePlayerNumber, enemyList } = state;\r\n\r\n  const enemyIndex =\r\n    deadPlayerList && deadPlayerList[activePlayerNumber].index\r\n      ? deadPlayerList[activePlayerNumber].index\r\n      : null;\r\n\r\n  if (enemyIndex) {\r\n    const nextEnemyCoordString = Object.values(newCoord).join(\".\");\r\n\r\n    const canTakeNextCell =\r\n      state.gameState.coordOfAvailableCells?.includes(nextEnemyCoordString);\r\n\r\n    switch (canTakeNextCell) {\r\n      case true: {\r\n        const enemyListArray = Object.entries(enemyList).map((enemyItem) => {\r\n          const [key, enemy] = enemyItem;\r\n          if (Number(enemyIndex) === Number(key)) {\r\n            const newEnemy = { ...enemy, coord: nextEnemyCoordString };\r\n            return [key, newEnemy];\r\n          } else return enemyItem;\r\n        });\r\n\r\n        const newEnemyList: EnemyListType = Object.fromEntries(enemyListArray);\r\n\r\n        return {\r\n          ...state,\r\n          gameState: { ...state.gameState, coordOfAvailableCells: null },\r\n          enemyList: newEnemyList,\r\n          doEffect: { type: \"!getPlayerMoveResult\" },\r\n        };\r\n      }\r\n\r\n      case false: {\r\n        return state;\r\n      }\r\n\r\n      default: {\r\n        return state;\r\n      }\r\n    }\r\n  } else {\r\n    return state;\r\n  }\r\n};\r\n","import { ActionType } from \"../../reducer\";\r\nimport { EnemyListType, State } from \"../../types\";\r\nimport { getNextPlayerCoord } from \"../common\";\r\n\r\nexport const getStateEnemyMoved = (state: State, action: ActionType): State => {\r\n  switch (action.type) {\r\n    case \"moveControlsClicked\": {\r\n      const { deadPlayerList, activePlayerNumber, enemyList } = state;\r\n      const direction = action.payload;\r\n\r\n      const enemyIndex =\r\n        deadPlayerList && deadPlayerList[activePlayerNumber].index\r\n          ? deadPlayerList[activePlayerNumber].index\r\n          : null;\r\n\r\n      if (enemyIndex) {\r\n        const prevEnemyCoord = enemyList[enemyIndex].coord;\r\n\r\n        const nextEnemyCoord = getNextPlayerCoord(prevEnemyCoord, direction);\r\n\r\n        //TODO: Add check canTakeNextCell\r\n        const canTakeNextCell =\r\n          state.gameState.coordOfAvailableCells?.includes(nextEnemyCoord);\r\n\r\n        switch (canTakeNextCell) {\r\n          case true: {\r\n            const enemyListArray = Object.entries(enemyList).map(\r\n              (enemyItem) => {\r\n                const [key, enemy] = enemyItem;\r\n                if (Number(enemyIndex) === Number(key)) {\r\n                  const newEnemy = { ...enemy, coord: nextEnemyCoord };\r\n                  return [key, newEnemy];\r\n                } else return enemyItem;\r\n              }\r\n            );\r\n\r\n            const newEnemyList: EnemyListType =\r\n              Object.fromEntries(enemyListArray);\r\n\r\n            return {\r\n              ...state,\r\n              gameState: { ...state.gameState, coordOfAvailableCells: null },\r\n              enemyList: newEnemyList,\r\n              doEffect: { type: \"!getPlayerMoveResult\" },\r\n            };\r\n          }\r\n          case false: {\r\n            return state;\r\n          }\r\n\r\n          default: {\r\n            return state;\r\n          }\r\n        }\r\n      } else {\r\n        return state;\r\n      }\r\n    }\r\n  }\r\n\r\n  return state;\r\n};\r\n","import { DeadPlayerListType, State } from \"../../types\";\r\n\r\n/**\r\n * new state depending on the result of the enemys's movement.\r\n */\r\nexport const getEnemyMoveResult = (state: State) => {\r\n  const { playerList, activePlayerNumber, dice, enemyList, deadPlayerList } =\r\n    state;\r\n\r\n  const enemyIndex =\r\n    deadPlayerList && deadPlayerList[activePlayerNumber].index\r\n      ? deadPlayerList[activePlayerNumber].index\r\n      : null;\r\n\r\n  const deadPLayerCoord = enemyIndex ? enemyList[enemyIndex].coord : null;\r\n\r\n  if (deadPLayerCoord) {\r\n    const isLastStepOfMove = dice === 1;\r\n\r\n    /**\r\n     * indexMetPlayerCard  can be 0\r\n     */\r\n\r\n    const indexMetPlayerCard = Object.values(playerList).find((playerItem) => {\r\n      return playerItem.coord === deadPLayerCoord;\r\n    })?.orderNumber;\r\n\r\n    const metPlayerCard =\r\n      indexMetPlayerCard || indexMetPlayerCard === 0 ? true : false;\r\n\r\n    // TODO: Is flat switch okey? Or i need it nested?!\r\n    switch (true) {\r\n      case metPlayerCard: {\r\n        if (\r\n          (deadPlayerList && indexMetPlayerCard) ||\r\n          (deadPlayerList && indexMetPlayerCard === 0)\r\n        ) {\r\n          /**\r\n           * DeadPlayerList without index of active card\r\n           */\r\n          const newDeadPlayerList: DeadPlayerListType = Object.fromEntries(\r\n            Object.entries(deadPlayerList).map(\r\n              ([orderIndex, deadPlayerItem]) => {\r\n                const { name, orderNumber } = deadPlayerItem;\r\n                return [orderIndex, { name, orderNumber }];\r\n              }\r\n            )\r\n          );\r\n\r\n          const newState: State = {\r\n            ...state,\r\n            dice: state.dice - 1,\r\n            gameState: {\r\n              ...state.gameState,\r\n              attackInitiator: activePlayerNumber,\r\n              type: \"interactWithEnemy.throwBattleDice\",\r\n            },\r\n            activePlayerNumber: indexMetPlayerCard,\r\n            deadPlayerList: newDeadPlayerList,\r\n          };\r\n\r\n          return newState;\r\n        } else {\r\n          return state;\r\n        }\r\n      }\r\n\r\n      case isLastStepOfMove: {\r\n        const newState: State = {\r\n          ...state,\r\n          doEffect: { type: \"!switchToNextPlayer\" },\r\n        };\r\n\r\n        return newState;\r\n      }\r\n\r\n      default: {\r\n        const newState: State = {\r\n          ...state,\r\n          dice: state.dice - 1,\r\n          doEffect: { type: \"!checkAvailableNeighboringCell\" },\r\n        };\r\n        return newState;\r\n      }\r\n    }\r\n  } else {\r\n    return state;\r\n  }\r\n};\r\n","import { reducer } from \"./reducer\";\r\nimport { createStore} from \"redux\";\r\n\r\nexport const store = createStore(\r\n  reducer,\r\n  (window as any).__REDUX_DEVTOOLS_EXTENSION__ &&\r\n    (window as any).__REDUX_DEVTOOLS_EXTENSION__()\r\n);","import { initialState } from \"./initialState\";\r\nimport { waitingStart } from \"./phases/waitingStart\";\r\nimport {\r\n  rollDice,\r\n  playerMove,\r\n  takeCard,\r\n  interactWithEnemy,\r\n  applyCard,\r\n} from \"./phases/gameStarted\";\r\nimport { endGame } from \"./phases/endGame\";\r\nimport {\r\n  ContextMenuButtonType,\r\n  CoordItem,\r\n  EnemyCardType,\r\n  MoveDirection,\r\n  PLayerType,\r\n  State,\r\n  TypeOfInventoryCard,\r\n} from \"./types\";\r\nimport { getPlayersOrder } from \"./phases/gameStarted/getPlayersOrder\";\r\nimport { enemyMove } from \"./phases/enemyMove\";\r\n\r\nexport type ActionType =\r\n  | { type: \"clickedStartButton\" }\r\n  | { type: \"diceThrown\"; payload: number }\r\n  | { type: \"moveControlsClicked\"; payload: MoveDirection }\r\n  | { type: \"playerWasMoved\"; payload: CoordItem }\r\n  | { type: \"req-openCard\" }\r\n  | { type: \"req-checkInventoryCard\" }\r\n  | { type: \"req-changePlayerHealth\" }\r\n  | { type: \"req-deleteCard\" }\r\n  | { type: \"req-checkEnemyCard\" }\r\n  | { type: \"req-openEnemyCard\" }\r\n  | { type: \"req-getBattleResult\" }\r\n  | { type: \"req-getEndScreen\" }\r\n  | { type: \"req-checkAvailableNeighboringCell\" }\r\n  | { type: \"req-checkAvailableNeighboringCards\" }\r\n  | { type: \"req-getPlayerMoveResult\" }\r\n  | { type: \"req-switchToNextPlayer\" }\r\n  | { type: \"req-takeCard\" }\r\n  | {\r\n      type: \"cardChoosed\";\r\n      payload: { type: TypeOfInventoryCard };\r\n    }\r\n  | { type: \"req-choosePlayer\" }\r\n  | {\r\n      type: \"req-fillHole\";\r\n      payload: { coord: number; direction: MoveDirection };\r\n    }\r\n  | { type: \"clickedEnemy\"; payload: { enemyCard: EnemyCardType } }\r\n  | { type: \"clickedSkip\" }\r\n  | { type: \"req-removeEnemyCard\" }\r\n  | { type: \"clickedPlayer\"; payload: PLayerType }\r\n  | {\r\n      type: \"clickedContextMenu\";\r\n      payload: { card: PLayerType; buttonType: ContextMenuButtonType };\r\n    }\r\n  | { type: \"req-getNextPlayer\" };\r\n\r\nexport const reducer = (\r\n  state: State = initialState,\r\n  action: ActionType\r\n): State => {\r\n  const [phaseOuter, phaseInner] = state.gameState.type.split(\".\");\r\n\r\n  switch (phaseOuter) {\r\n    case \"waitingStart\": {\r\n      return waitingStart(state, action);\r\n    }\r\n\r\n    case \"gameStarted\": {\r\n      switch (phaseInner) {\r\n        case \"rollDice\": {\r\n          return rollDice(state, action);\r\n        }\r\n\r\n        case \"playerMove\": {\r\n          return playerMove(state, action);\r\n        }\r\n\r\n        case \"takeCard\": {\r\n          return takeCard(state, action);\r\n        }\r\n        case \"applyCard\": {\r\n          return applyCard(state, action);\r\n        }\r\n\r\n        case \"getPlayersOrder\": {\r\n          return getPlayersOrder(state, action);\r\n        }\r\n\r\n        default:\r\n          return state;\r\n      }\r\n    }\r\n\r\n    case \"enemyMove\": {\r\n      return enemyMove(state, action);\r\n    }\r\n\r\n    case \"interactWithEnemy\": {\r\n      return interactWithEnemy(state, action);\r\n    }\r\n\r\n    case \"endGame\": {\r\n      return endGame(state, action);\r\n    }\r\n\r\n    default:\r\n      return state;\r\n  }\r\n};\r\n","import React, { useMemo } from \"react\";\r\nimport { useDispatch, useSelector } from \"react-redux\";\r\n\r\nimport styled from \"styled-components\";\r\nimport { State } from \"../business/types\";\r\n\r\nconst SkipButtonContainer = styled.button`\r\n  height: 40px;\r\n  width: 85px;\r\n  cursor: pointer;\r\n`;\r\n\r\nexport const SkipButton = () => {\r\n  const dispatch = useDispatch();\r\n\r\n  const enemyList = useSelector((state: State) => state.enemyList);\r\n  const gameState = useSelector((state: State) => state.gameState);\r\n\r\n  const activePlayerDead = useSelector((state: State) => {\r\n    const activePlayerNumber = state.activePlayerNumber;\r\n    const isPlayerDead =\r\n      state.deadPlayerList && state.deadPlayerList[activePlayerNumber];\r\n    return Boolean(isPlayerDead);\r\n  });\r\n\r\n  const hasOpenEnemyCard = Object.values(enemyList).some((enemyCard) => {\r\n    return enemyCard.appearance === \"open\";\r\n  });\r\n\r\n  const canSkip =\r\n    gameState.type === \"gameStarted.rollDice\" && activePlayerDead\r\n      ? !hasOpenEnemyCard\r\n      : false;\r\n\r\n  const MemoButton = useMemo(() => SkipButtonContainer, [canSkip]);\r\n  return (\r\n    <MemoButton\r\n      disabled={!canSkip}\r\n      onClick={() => {\r\n        dispatch({\r\n          type: \"clickedSkip\",\r\n        });\r\n      }}\r\n    >\r\n      пропустить ход\r\n    </MemoButton>\r\n  );\r\n};\r\n","import { Provider, useSelector } from \"react-redux\";\r\n\r\nimport styled from \"styled-components\";\r\nimport \"./index.css\";\r\nimport { PlayGrid, Dice, StatusList, MoveControls } from \"./features\";\r\nimport { StartScreen, EndScreen } from \"./pages\";\r\nimport { State } from \"./business/types\";\r\nimport { store } from \"./business/store\";\r\n\r\nimport {\r\n  useOpenCard,\r\n  useEndScreen,\r\n  usePlayerMove,\r\n  useInteractWithEnemy,\r\n  useApplyCard,\r\n} from \"./business/effects\";\r\nimport { useMemo } from \"react\";\r\nimport { SkipButton } from \"./features/SkipButton\";\r\n\r\n/* import { PlayerStatus } from \"./features/PlayerStatus\"; */\r\n\r\nconst Field = styled.div`\r\n  margin: 0 auto;\r\n`;\r\n\r\nconst Game = styled.div`\r\n  width: 1050px;\r\n  height: 600px;\r\n  margin: 40px auto;\r\n  display: flex;\r\n  justify-content: center;\r\n\r\n  cursor: default;\r\n  & > * {\r\n  }\r\n`;\r\n\r\nconst RightPanel = styled.div`\r\n  width: 300px;\r\n  height: 600px;\r\n  display: flex;\r\n  flex-direction: column;\r\n  justify-content: space-between;\r\n  align-items: center;\r\n  flex-grow: 0;\r\n  align-items: start;\r\n  margin: 0 30px;\r\n  padding: 50px 0;\r\n  box-sizing: border-box;\r\n  & > * {\r\n  }\r\n`;\r\n\r\nconst LeftPanel = styled.div`\r\n  display: flex;\r\n  align-self: start;\r\n  background-color: white;\r\n  height: 100px;\r\n  margin: 0 30px;\r\n  border-radius: 5px;\r\n  padding: 5px 0;\r\n`;\r\n\r\nconst GameControls = styled.div`\r\n  display: flex;\r\n  width: 100%;\r\n  justify-content: space-between;\r\n  box-sizing: border-box;\r\n  align-items: center;\r\n`;\r\n\r\nexport function GetApp() {\r\n  const gameState = useSelector((state: State) => state.gameState);\r\n\r\n  useOpenCard();\r\n  usePlayerMove();\r\n  useEndScreen();\r\n  useInteractWithEnemy();\r\n  useApplyCard();\r\n\r\n  const memoizedMainPage = useMemo(() => {\r\n    return (\r\n      <>\r\n        <LeftPanel>{/*  <PlayersStatusList /> */}</LeftPanel>\r\n        <Field id=\"field\">\r\n          <PlayGrid />\r\n        </Field>\r\n        <RightPanel>\r\n          <StatusList />\r\n          <GameControls>\r\n            <Dice />\r\n            <SkipButton />\r\n            {/* <MoveControls /> */}\r\n          </GameControls>\r\n          {/*  <PlayerStatus /> */}\r\n        </RightPanel>\r\n      </>\r\n    );\r\n  }, []);\r\n\r\n  const getGameScreen = () => {\r\n    switch (gameState.type) {\r\n      case \"waitingStart\":\r\n        return <StartScreen />;\r\n\r\n      case \"getEndScreen\":\r\n        return <EndScreen />;\r\n\r\n      default:\r\n        return memoizedMainPage;\r\n    }\r\n  };\r\n\r\n  // const memoizedGetApp = useMemo(() => {\r\n  //   return ;\r\n  // }, [gameState.type]);\r\n  return <Game>{getGameScreen()}</Game>;\r\n}\r\n\r\nexport const App = () => {\r\n  return (\r\n    <Provider store={store}>\r\n      <GetApp />\r\n    </Provider>\r\n  );\r\n};\r\n","import { useEffect } from \"react\";\r\nimport { useSelector, useDispatch } from \"react-redux\";\r\n\r\nimport { State } from \"../types\";\r\n\r\nexport function useOpenCard() {\r\n  const doEffect = useSelector((state: State) => state.doEffect);\r\n  const dispatch = useDispatch();\r\n\r\n  useEffect(\r\n    function openCard() {\r\n      switch (doEffect?.type) {\r\n        case \"!checkAppearanceInventoryCard\": {\r\n          dispatch({\r\n            type: \"req-checkInventoryCard\",\r\n          });\r\n          break;\r\n        }\r\n\r\n        case \"!takeCard\": {\r\n          dispatch({\r\n            type: \"req-takeCard\",\r\n          });\r\n          break;\r\n        }\r\n\r\n        case \"!changePlayerHealth\": {\r\n          const timerChangePlayerHealth = setTimeout(\r\n            () =>\r\n              dispatch({\r\n                type: \"req-changePlayerHealth\",\r\n              }),\r\n            500\r\n          );\r\n          return () => {\r\n            clearTimeout(timerChangePlayerHealth);\r\n          };\r\n        }\r\n\r\n        case \"!deleteCard\": {\r\n          const timerDeleteCard = setTimeout(\r\n            () =>\r\n              dispatch({\r\n                type: \"req-deleteCard\",\r\n              }),\r\n            500\r\n          );\r\n          return () => {\r\n            clearTimeout(timerDeleteCard);\r\n          };\r\n        }\r\n\r\n        default: {\r\n          break;\r\n        }\r\n      }\r\n    },\r\n    //eslint-disable-next-line\r\n    [doEffect]\r\n  );\r\n}\r\n","import { useEffect } from \"react\";\r\nimport { useSelector, useDispatch } from \"react-redux\";\r\n\r\nimport { State } from \"../types\";\r\n\r\nexport function usePlayerMove() {\r\n  const doEffect = useSelector((state: State) => state.doEffect);\r\n  const dispatch = useDispatch();\r\n\r\n  useEffect(\r\n    function playerMove() {\r\n      switch (doEffect?.type) {\r\n        case \"!checkAvailableNeighboringCell\": {\r\n          dispatch({\r\n            type: \"req-checkAvailableNeighboringCell\",\r\n          });\r\n          break;\r\n        }\r\n\r\n        case \"!getPlayerMoveResult\": {\r\n          dispatch({\r\n            type: \"req-getPlayerMoveResult\",\r\n          });\r\n          break;\r\n        }\r\n\r\n        case \"!switchToNextPlayer\": {\r\n          dispatch({\r\n            type: \"req-switchToNextPlayer\",\r\n          });\r\n          break;\r\n          // const timerMoveResult = setTimeout(\r\n          //   () =>\r\n          //     dispatch({\r\n          //       type: \"req-switchToNextPlayer\",\r\n          //     }),\r\n          //   500\r\n          // );\r\n\r\n          // return () => {\r\n          //   clearTimeout(timerMoveResult);\r\n          // };\r\n        }\r\n\r\n        default:\r\n          break;\r\n      }\r\n    },\r\n    //eslint-disable-next-line\r\n    [doEffect]\r\n  );\r\n}\r\n","import { useEffect } from \"react\";\r\nimport { useSelector, useDispatch } from \"react-redux\";\r\n\r\nimport { State } from \"../types\";\r\n\r\nexport function useEndScreen() {\r\n  const dispatch = useDispatch();\r\n  const gameState = useSelector((state: State) => state.gameState);\r\n\r\n  useEffect(\r\n    function getEndScreen() {\r\n      switch (gameState.type) {\r\n        case \"endGame\":\r\n          const timer = setTimeout(\r\n            () => dispatch({ type: \"req-getEndScreen\" }),\r\n            1000\r\n          );\r\n\r\n          return () => clearTimeout(timer);\r\n\r\n        default:\r\n          break;\r\n      }\r\n    },\r\n    //eslint-disable-next-line\r\n    [gameState.type, dispatch]\r\n  );\r\n}\r\n","import { useEffect } from \"react\";\r\nimport { useSelector, useDispatch } from \"react-redux\";\r\n\r\nimport { State } from \"../types\";\r\n\r\nexport function useInteractWithEnemy() {\r\n  const doEffect = useSelector((state: State) => state.doEffect);\r\n  const dispatch = useDispatch();\r\n\r\n  useEffect(() => {\r\n    switch (doEffect?.type) {\r\n      case \"!checkAppearanceEnemyCard\": {\r\n        dispatch({\r\n          type: \"req-checkEnemyCard\",\r\n        });\r\n        break;\r\n      }\r\n\r\n      // case \"!openEnemyCard\": {\r\n      //   const timerOpen = setTimeout(\r\n      //     () =>\r\n      //       dispatch({\r\n      //         type: \"req-openEnemyCard\",\r\n      //       }),\r\n      //     1000\r\n      //   );\r\n      //   return () => {\r\n      //     clearTimeout(timerOpen);\r\n      //   };\r\n      // }\r\n\r\n      case \"!getBattleResult\": {\r\n        const timerGetResult = setTimeout(\r\n          () => dispatch({ type: \"req-getBattleResult\" }),\r\n          2000\r\n        );\r\n\r\n        return () => {\r\n          clearTimeout(timerGetResult);\r\n        };\r\n      }\r\n\r\n      case \"!removeEnemyCard\": {\r\n        const timerRemoveEnemy = setTimeout(\r\n          () => dispatch({ type: \"req-removeEnemyCard\" }),\r\n          1000\r\n        );\r\n        return () => {\r\n          clearTimeout(timerRemoveEnemy);\r\n        };\r\n      }\r\n      default: {\r\n        break;\r\n      }\r\n    }\r\n    //eslint-disable-next-line\r\n  }, [doEffect]);\r\n}\r\n","import { useEffect } from \"react\";\r\nimport { useSelector, useDispatch } from \"react-redux\";\r\n\r\nimport { State } from \"../types\";\r\n\r\nexport function useApplyCard() {\r\n  const doEffect = useSelector((state: State) => state.doEffect);\r\n  const dispatch = useDispatch();\r\n\r\n  useEffect(\r\n    function playerMove() {\r\n      switch (doEffect?.type) {\r\n        case \"!checkAvailableNeighboringCards\": {\r\n          dispatch({\r\n            type: \"req-checkAvailableNeighboringCards\",\r\n          });\r\n          break;\r\n        }\r\n\r\n        default:\r\n          break;\r\n      }\r\n    },\r\n    //eslint-disable-next-line\r\n    [doEffect]\r\n  );\r\n}\r\n","import { ReportHandler } from 'web-vitals';\r\n\r\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\r\n  if (onPerfEntry && onPerfEntry instanceof Function) {\r\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\r\n      getCLS(onPerfEntry);\r\n      getFID(onPerfEntry);\r\n      getFCP(onPerfEntry);\r\n      getLCP(onPerfEntry);\r\n      getTTFB(onPerfEntry);\r\n    });\r\n  }\r\n};\r\n\r\nexport default reportWebVitals;\r\n","import React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\nimport { App } from \"./App\";\r\nimport reportWebVitals from \"./reportWebVitals\";\r\n\r\nimport { DndProvider } from \"react-dnd\";\r\nimport { HTML5Backend } from \"react-dnd-html5-backend\";\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <DndProvider backend={HTML5Backend}>\r\n      <App />\r\n    </DndProvider>\r\n  </React.StrictMode>,\r\n  document.getElementById(\"root\")\r\n);\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals();\r\n"],"sourceRoot":""}